//
// Script Document.cpp : Functions for the creation and display of script document windows
//
// NB: Best viewed with tab size of 3 characters and Visual Studio's 'XML Doc Comment' syntax colouring
//         set to a colour that highly contrasts the 'C/C++ comment' syntax colouring
// 

#include "stdafx.h"

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                  CONSTANTS / GLOBALS / MACROS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

// AutoSave timer ID
CONST UINT      AUTOSAVE_TICKER      = 1;

// Print document after an exception
#define  ON_EXCEPTION()    debugScriptDocument(pDocument);  displayException(pException);

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                       CREATION / DESTRUCTION
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          HELPERS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////


/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          FUNCTIONS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : updateScriptDocumentLabelsCombo
// Description     : Re-Populate the 'Labels' ComboBox using a label data provided by the CodeEdit
// 
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument data
// 
VOID   updateScriptDocumentLabelsCombo(SCRIPT_DOCUMENT*  pDocument)
{
   CODE_EDIT_LOCATION  oCaretLocation;       // Current location of the caret in the CodeEdit
   CODE_EDIT_LABEL*    pCurrentLabel = NULL; // The Label currently being processed
   QUEUE*              pLabelQueue = NULL;   // Queue of label names and locations, generated by the CodeEdit
   TCHAR*              szLineNumber;         // One-based line number for display in the ComboBox
   UINT                iNewItemIndex;        // Zero-based ComboBox item index of the item currently being processed

   TRY
   {
      // [TRACK]
      CONSOLE_COMMAND1(getDocumentFileName(pDocument));
      
      // Prepare
      szLineNumber = utilCreateEmptyString(32);

      /// Get the label queue and caret location from the CodeEdit
      pLabelQueue = CodeEdit_GetLabelQueue(pDocument->hCodeEdit);
      CodeEdit_GetCaretLocation(pDocument->hCodeEdit, &oCaretLocation);
      CONSOLE("Document LabelsQueue contains %d items", pLabelQueue->iCount);

      // Erase current ComboBox contents
      ComboBox_ResetContent(pDocument->hLabelsCombo);

      /// Add first item '(Global Scope)' and select it
      appendCustomComboBoxItem(pDocument->hLabelsCombo, loadTempString(IDS_SCRIPT_GLOBAL_SCOPE));
      ComboBox_SetCurSel(pDocument->hLabelsCombo, 0);
      
      // Iterate through labels in the queue
      while (pCurrentLabel = (CODE_EDIT_LABEL*)popFirstQueueObject(pLabelQueue))
      {
         // Format one-based line number for new ComboItem
         StringCchPrintf(szLineNumber, 32, TEXT("Line %u"), pCurrentLabel->iLineNumber + 1);
         //VERBOSE("Document label '%s' on line %d", pCurrentLabel->szName, pCurrentLabel->iLineNumber + 1);

         /// Append new ComboItem and store line number as item data
         iNewItemIndex = appendCustomComboBoxItemEx(pDocument->hLabelsCombo, pCurrentLabel->szName, szLineNumber, TEXT("FUNCTION_ICON"), pCurrentLabel->iLineNumber);

         /// Select this label if equal/preceeds the current line
         if (pCurrentLabel->iLineNumber <= oCaretLocation.iLine)
            ComboBox_SetCurSel(pDocument->hLabelsCombo, iNewItemIndex);

         // Cleanup
         deleteCodeEditLabel(pCurrentLabel);
      }

      // Cleanup
      utilDeleteString(szLineNumber);
      deleteQueue(pLabelQueue);
      return;
   }
   CATCH2("Unable to update labels combo: Caret is (%d,%d)", oCaretLocation.iIndex, oCaretLocation.iLine);
   debugCodeEditLabel(pCurrentLabel);
   debugQueue(pLabelQueue);
   
   ComboBox_ResetContent(pDocument->hLabelsCombo);
}


/// Function name  : updateScriptDocumentVariablesCombo
// Description     : Fill the variables combo box with a list of variables used in the document
//
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument window data
// 
VOID     updateScriptDocumentVariablesCombo(SCRIPT_DOCUMENT*  pDocument)
{
   VARIABLE_NAME*  pCurrentVariable = NULL;  // VariableName currently being processed
   AVL_TREE*       pVariablesTree = NULL;    // VariableNames tree for the CodeEdit
   TCHAR          *szVariableCount = NULL;   // Number of times the current variable occurs
   UINT            iOriginalSelection;       // Original ComboBox selection index

   TRY
   {
      // [TRACK]
      CONSOLE_COMMAND1(getDocumentFileName(pDocument));   //CONSOLE("Updating ScriptDocument Variables ComboBox");

      // Prepare
      szVariableCount = utilCreateEmptyString(32);

      // Clear combo box
      iOriginalSelection = ComboBox_GetCurSel(pDocument->hVariablesCombo);
      ComboBox_ResetContent(pDocument->hVariablesCombo);

      /// Generate variables tree for document
      pVariablesTree = CodeEdit_GetVariableNameTree(pDocument->hCodeEdit);
      CONSOLE("Document variables tree contains %d items", getTreeNodeCount(pVariablesTree));

      /// [DEFAULT] Add each entry in the tree to the ComboBox
      if (getTreeNodeCount(pVariablesTree) > 0)
      {
         // Add "(Document Variables)" Heading
         appendCustomComboBoxItem(pDocument->hVariablesCombo, loadTempString(IDS_SCRIPT_DOCUMENT_VARIABLES));

         // Iterate through variables tree, backwards
         for (UINT iVariableIndex = 0; findObjectInAVLTreeByIndex(pVariablesTree, iVariableIndex, (LPARAM&)pCurrentVariable); iVariableIndex++)
         {
            // Generate UsageCount text
            StringCchPrintf(szVariableCount, 32, TEXT("%u Uses"), pCurrentVariable->iCount);
            //VERBOSE("Document variable '%s' used %d times", pCurrentVariable->szName, pCurrentVariable->iCount);
            
            /// Append new ComboItem containing <name> and <uses> 
            appendCustomComboBoxItemEx(pDocument->hVariablesCombo, pCurrentVariable->szName, szVariableCount, TEXT("VARIABLE_ICON"), NULL);
         }
      }
      /// [NONE] Display a special heading if there are no variables
      else
         appendCustomComboBoxItem(pDocument->hVariablesCombo, findNextPackedString(loadTempString(IDS_SCRIPT_DOCUMENT_VARIABLES)));
         
      // Restore original selection
      ComboBox_SetCurSel(pDocument->hVariablesCombo, iOriginalSelection);
   
      // Cleanup
      utilDeleteString(szVariableCount);
      deleteAVLTree(pVariablesTree);
      return;
   }
   CATCH0("Unable to update variables combo");
   debugVariableName(pCurrentVariable);
   debugTree(pVariablesTree);

   ComboBox_ResetContent(pDocument->hVariablesCombo);
}

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          MESSAGE HANDLERS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : onScriptDocumentAutoSave
// Description     : Silently saves a backup of the current document text
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Document
// 
VOID  onScriptDocumentAutoSave(SCRIPT_DOCUMENT*  pDocument)
{
   TCHAR   *szPath,        // Backup path
           *szText;        // CodeEdit text
   CHAR    *szOutput;      // CodeEdit text in aNSI
   UINT     iLength,       // Length of CodeEdit text
            iOutput = 0;   // Number of bytes output
   HANDLE   hFile;         // File handle

   TRY
   {
      // [TRACK]
      CONSOLE_EVENT1(getDocumentFileName(pDocument));

      // Ensure document is modified
      if (!isModified(pDocument) OR pDocument->bUntitled)
         return;

      // Generate full path of backup file
      szPath = utilDuplicatePath(pDocument->szFullPath);
      PathRenameExtension(szPath, TEXT(".bak"));
         
      // Retrieve null-terminated window text
      szText = utilCreateString(iLength = 2*GetWindowTextLength(pDocument->hCodeEdit));   // HACK: CodeEdit is mis-representing the length of the text 
      GetWindowText(pDocument->hCodeEdit, szText, iLength);

      // Convert to ANSI
      szOutput = utilTranslateStringToANSI(szText, iLength=lstrlen(szText));
         
      /// Overwrite previous backup file, if any
      if ((hFile = CreateFile(szPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
      {
         WriteFile(hFile, szOutput, lstrlenA(szOutput), (DWORD*)&iOutput, NULL);
         utilCloseHandle(hFile);
      }

      // [DEBUG] VERBOSE("** CodeEdit Length = %d, Text='%s'", iLength, szText);

      // Cleanup
      utilDeleteStrings(szPath, szText);
      utilDeleteStringA(szOutput);
   }
   CATCH1("Unable to auto-save document: szPath='%s'", szPath);
}


/// Function name  : onScriptDocumentContextMenu
// Description     : Display the CodeEdit popup menu
// 
// SCRIPT_DOCUMENT*  pDocument  : [in] ScriptDocument window data
// HWND              hDialog    : [in] ScriptDocument window handle
// CONST POINT*      ptCursor   : [in] Cursor position in screen co-ordinates
// HWND              hCtrl      : [in] Control sending the message
// 
VOID   onScriptDocumentContextMenu(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog, CONST POINT*  ptCursor, HWND  hCtrl)
{
   //GAME_STRING*    pDependency;         // GameString dependency of COMMAND, if any
   CUSTOM_MENU*    pCustomMenu;         // Popup CustomMenu
   CONST TCHAR*    szTargetLabel;       // Name of label targetted by COMMAND, if any
   ERROR_QUEUE*    pErrorQueue;         // CodeEdit line error, if any
   COMMAND*        pCommand;            // CodeEdit line COMMAND

   TRY
   {
      /// [CODE-EDIT]
      if (GetDlgCtrlID(hCtrl) == IDC_CODE_EDIT) 
      {
         CONSOLE_ACTION1(getDocumentFileName(pDocument));

         // Lookup line COMMAND and ERROR-QUEUE (if any)
         pErrorQueue = CodeEdit_GetCaretLineError(pDocument->hCodeEdit);
         pCommand    = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);

         // [DEBUG] Ensure COMMAND exists
         CONSOLE("Text selection=%d.  Retrieving caret COMMAND:", CodeEdit_HasSelection(pDocument->hCodeEdit));
         debugCommand(pCommand);
         ASSERT(pCommand);

         /// Create CustomMenu
         pCustomMenu = createCustomMenu(TEXT("SCRIPT_MENU"), TRUE, IDM_CODE_EDIT_POPUP);

         /// [SELECTION] Enable items based on advice from the CodeEdit
         EnableMenuItem(pCustomMenu->hPopup, IDM_EDIT_CUT,    (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));
         EnableMenuItem(pCustomMenu->hPopup, IDM_EDIT_COPY,   (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));
         EnableMenuItem(pCustomMenu->hPopup, IDM_EDIT_DELETE, (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));
         
         // [CHECK] Are there no errors?
         if (!pErrorQueue)
         {
            removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_ERROR, FALSE);        // [FIX] BUG:1030 'CodeEdit context menu item 'View Error' has the wrong icon and doesn't be reflect severity of the actual error'
            removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_WARNING, FALSE);
         }
         else
         {  /// [ERROR/WARNING] Display item with correct severity
            VERBOSE("Errors are present within COMMAND");
            removeCustomMenuItem(pCustomMenu->hPopup, (identifyErrorQueueType(pErrorQueue) == ET_ERROR ? IDM_CODE_EDIT_VIEW_WARNING : IDM_CODE_EDIT_VIEW_ERROR), FALSE);
         }

         // [CHECK] Is this auxiliary/expression command?
         if (isCommandType(pCommand, CT_AUXILIARY) OR isCommandID(pCommand, CMD_EXPRESSION))
            removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_LOOKUP_COMMAND, FALSE); 
         else
         {  /// [COMMAND HELP] Is MSCI URL present?
            VERBOSE("MSCI Reference URL presence = %d", isCommandReferenceURLPresent(pCommand->pSyntax));
            EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_LOOKUP_COMMAND, isCommandReferenceURLPresent(pCommand->pSyntax) ? MF_ENABLED : MF_DISABLED);
         }

         /// [SUGGESTIONS] Are suggestions available?
         VERBOSE("Suggestion presence = %d", CodeEdit_HasSuggestions(pDocument->hCodeEdit));
         EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_SUGGESTIONS, (CodeEdit_HasSuggestions(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));

         // [CHECK] Is this a script-call command?
         if (!isCommandType(pCommand, CT_SCRIPTCALL))
            removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_OPEN_TARGET_SCRIPT, FALSE);
         else
            /// [SCRIPT-CALL] Always enable
            EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_OPEN_TARGET_SCRIPT, MF_ENABLED);

         // [CHECK] Is this goto label or goto sub command?
         if (isCommandGotoLabel(pCommand, szTargetLabel))
         {
            /// [GOTO SUB/LABEL] Insert label name
            VERBOSE("Goto label available for '%s'", szTargetLabel);
            setCustomMenuItemText(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LABEL, FALSE, getCustomMenuItemData(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LABEL, FALSE)->szText, szTargetLabel);
         }
         else
            removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LABEL, FALSE);
         
         // [CHECK] Does command use GameStrings?
         if (!isCommandGameStringDependent(pCommand))
            removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LANGUAGE_STRING, FALSE);  
         else
         {
            /// [VIEW STRING] Is dependency present?
            VERBOSE("GameString dependency detected");
            EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LANGUAGE_STRING, CodeEdit_GetCaretGameString(pDocument->hCodeEdit, getActiveProjectFile()) ? MF_ENABLED : MF_DISABLED);
         }
            
         /// [PROPERTIES] Check based on whether the window is open or not
         CheckMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_PROPERTIES, (getMainWindowData()->hPropertiesSheet ? MF_CHECKED : MF_UNCHECKED));
         
         // Display the pop-up menu
         TrackPopupMenu(pCustomMenu->hPopup, TPM_LEFTALIGN WITH TPM_TOPALIGN WITH TPM_LEFTBUTTON, ptCursor->x, ptCursor->y, NULL, hDialog, NULL);
         deleteCustomMenu(pCustomMenu);
      }

      return;
   }
   CATCH0("Unable to create document context menu");
}


/// Function name  : onScriptDocumentCommand
// Description     : Handle notifications from the child controls
//
// SCRIPT_DOCUMENT*  pDocument     : [in] Document data
// CONST UINT        iControlID    : [in] ID of the control sending the notification
// CONST UINT        iNotification : [in] Notification code
// 
// Return type : TRUE if processed, FALSE if not
//
BOOL   onScriptDocumentCommand(SCRIPT_DOCUMENT*  pDocument, CONST UINT  iControlID, CONST UINT  iNotification)
{
   UINT    iLabelLineNumber;
   BOOL    bResult = TRUE;
   
   TRY
   {
      // Examine source
      switch (iControlID)
      {
      /// [CODE EDIT]
      case IDC_CODE_EDIT:
         switch (iNotification)
         {
         case EN_SETFOCUS:    CONSOLE("CodeEdit receiving input focus");      break;
         case EN_KILLFOCUS:   CONSOLE("CodeEdit losing input focus");         break;
         }  
         break;

      /// [VARIABLES COMBO-BOX]
      case IDC_VARIABLES_COMBO:
         switch (iNotification)
         {
         // [OPEN] Populate with all the variables in the CodeEdit
         case CBN_DROPDOWN:
            CONSOLE_UI(IDC_VARIABLES_COMBO, CBN_DROPDOWN);
            updateScriptDocumentVariablesCombo((SCRIPT_DOCUMENT*)pDocument);
            break;

         // [CLOSE] Return focus to the CodeEdit
         case CBN_CLOSEUP:
            CONSOLE_UI(IDC_VARIABLES_COMBO, CBN_CLOSEUP);
            SetFocus(pDocument->hCodeEdit);
            break;

         // [UNHANDLED]
         default:
            bResult = FALSE;
            break;
         }
         break;

      /// [LABELS COMBOBOX]
      case IDC_LABELS_COMBO:
         switch (iNotification)
         {
         // [OPEN] Populate with all the labels in the CodeEdit
         case CBN_DROPDOWN:
            CONSOLE_UI(IDC_LABELS_COMBO, CBN_DROPDOWN);
            updateScriptDocumentLabelsCombo((SCRIPT_DOCUMENT*)pDocument);
            break;

         // [CLICK] Scroll the CodeEdit to the desired label
         case CBN_SELCHANGE:
            CONSOLE_UI(IDC_LABELS_COMBO, CBN_SELCHANGE);

            // Lookup label Line number, stored as item data
            iLabelLineNumber = getCustomComboBoxItemParam(pDocument->hLabelsCombo, ComboBox_GetCurSel(pDocument->hLabelsCombo));
            CONSOLE("Item %d selected. Scrolling CodeEdit to line %d", ComboBox_GetCurSel(pDocument->hLabelsCombo), iLabelLineNumber);

            // Scroll CodeEdit to the label 
            CodeEdit_ScrollToLocation(pDocument->hCodeEdit, 0, iLabelLineNumber, TRUE);

            // Pass focus to the CodeEdit
            SetFocus(pDocument->hCodeEdit);
            break;

         // [UNHANDLED]
         default:
            bResult = FALSE;
            break;
         }
         break;

      /// [CUT/COPY/PASTE/DELETE]
      case IDM_EDIT_CUT:                        CONSOLE_MENU(IDM_EDIT_CUT);                        SendMessage(pDocument->hCodeEdit, WM_CUT, NULL, NULL);      break;
      case IDM_EDIT_COPY:                       CONSOLE_MENU(IDM_EDIT_COPY);                       SendMessage(pDocument->hCodeEdit, WM_COPY, NULL, NULL);     break;
      case IDM_EDIT_PASTE:                      CONSOLE_MENU(IDM_EDIT_PASTE);                      SendMessage(pDocument->hCodeEdit, WM_PASTE, NULL, NULL);    break;
      case IDM_EDIT_DELETE:                     CONSOLE_MENU(IDM_EDIT_DELETE);                     SendMessage(pDocument->hCodeEdit, WM_CLEAR, NULL, NULL);    break;

      /// [SELECT ALL/COMMENT/SUGGESTIONS]
      case IDM_EDIT_SELECT_ALL:                 CONSOLE_MENU(IDM_EDIT_SELECT_ALL);                 CodeEdit_SelectAll(pDocument->hCodeEdit);               break;
      case IDM_CODE_EDIT_VIEW_SUGGESTIONS:      CONSOLE_MENU(IDM_CODE_EDIT_VIEW_SUGGESTIONS);      CodeEdit_ShowSuggestions(pDocument->hCodeEdit, NULL);   break;
      case IDM_EDIT_COMMENT:                    CONSOLE_MENU(IDM_EDIT_COMMENT);    
         CodeEdit_CommentSelection(pDocument->hCodeEdit, !CodeEdit_IsSelectionCommented(pDocument->hCodeEdit));   break;

      /// [MSCI/VIEW-ERROR/OPEN-SCRIPT/GOTO-LABEL/VIEW-STRING]
      case IDM_CODE_EDIT_VIEW_ERROR:
      case IDM_CODE_EDIT_VIEW_WARNING:          CONSOLE_MENU(IDM_CODE_EDIT_VIEW_WARNING);          onScriptDocumentViewError(pDocument);           break;
      case IDM_CODE_EDIT_OPEN_TARGET_SCRIPT:    CONSOLE_MENU(IDM_CODE_EDIT_OPEN_TARGET_SCRIPT);    onScriptDocumentOpenTargetScript(pDocument);    break;
      case IDM_CODE_EDIT_VIEW_LABEL:            CONSOLE_MENU(IDM_CODE_EDIT_VIEW_LABEL);            onScriptDocumentGotoLabel(pDocument);           break;
      case IDM_CODE_EDIT_VIEW_LANGUAGE_STRING:  CONSOLE_MENU(IDM_CODE_EDIT_VIEW_LANGUAGE_STRING);  onScriptDocumentViewLanguageString(pDocument);  break;
      case IDM_CODE_EDIT_LOOKUP_COMMAND:        CONSOLE_MENU(IDM_CODE_EDIT_LOOKUP_COMMAND);        onScriptDocumentLookupCommand(pDocument);       break;

      /// [PROPERTIES]
      case IDM_CODE_EDIT_PROPERTIES:            CONSOLE_MENU(IDM_CODE_EDIT_PROPERTIES);            SendMessage(getAppWindow(), WM_COMMAND, IDM_VIEW_DOCUMENT_PROPERTIES, NULL);  break;
      }

      return bResult;
   }
   CATCH2("Unable to process command (%d, %d)", iControlID, iNotification);
   return FALSE;
}


/// Function name  : createScriptDialogControls
// Description     : 
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// 
VOID  createScriptDialogControls(SCRIPT_DOCUMENT*  pDocument)
{
   PANE_PROPERTIES   oPaneData;       // New pane properties
   PANE*             pTargetPane;     // Workspace pane being targetted for a split
   RECT              rcDialog;        // Dialog client rectangle
   SIZE              siDialog,        // Size of dialog rectangle
                     siComboBox;      // Size of ComboBox

   // Prepare
   GetClientRect(pDocument->hWnd, &rcDialog);
   utilConvertRectangleToSize(&rcDialog, &siDialog);

   /// [LABELS COMBO]
   pDocument->hLabelsCombo = CreateWindow(WC_COMBOBOX, TEXT("Labels Combo"), WS_CHILD WITH WS_TABSTOP WITH WS_VSCROLL WITH CBS_DROPDOWNLIST WITH CBS_OWNERDRAWFIXED, 0, 0, (siDialog.cx / 2), ITS_MEDIUM,
                                          pDocument->hWnd, (HMENU)IDC_LABELS_COMBO, getAppInstance(), NULL);
   ERROR_CHECK("Creating Labels ComboBox", pDocument->hLabelsCombo);

   /// [VARIABLES COMBO]
   pDocument->hVariablesCombo = CreateWindow(WC_COMBOBOX, TEXT("Variables Combo"), WS_CHILD WITH WS_TABSTOP WITH WS_VSCROLL WITH CBS_DROPDOWNLIST WITH CBS_OWNERDRAWFIXED, (siDialog.cx / 2), 0, (siDialog.cx / 2), ITS_MEDIUM, 
                                             pDocument->hWnd, (HMENU)IDC_VARIABLES_COMBO, getAppInstance(), NULL);
   ERROR_CHECK("Creating Variables ComboBox", pDocument->hVariablesCombo);

   /// [CODE EDIT]
   pDocument->hCodeEdit = CreateWindow(szCodeEditClass, TEXT("CodeEdit"), WS_CHILD WITH WS_TABSTOP, 0, 0, 400, 400, 
                                       pDocument->hWnd, (HMENU)IDC_CODE_EDIT, getControlsInstance(), NULL);
   ERROR_CHECK("Creating CodeEdit", pDocument->hCodeEdit);

   // Set ComboBox fonts
   SetWindowFont(pDocument->hLabelsCombo, GetStockFont(ANSI_VAR_FONT), FALSE);
   SetWindowFont(pDocument->hVariablesCombo, GetStockFont(ANSI_VAR_FONT), FALSE);

   // Measure ComboBox
   utilGetWindowSize(pDocument->hLabelsCombo, &siComboBox);

   /// Create workspace and insert CodeEdit
   pDocument->hWorkspace = createWorkspace(pDocument->hWnd, &rcDialog, pDocument->hCodeEdit, getTabThemeColour());

   // Search for CodeEdit pane
   if (findWorkspacePaneByHandle(pDocument->hWorkspace, pDocument->hCodeEdit, NULL, NULL, pTargetPane))
   {
      /// Add Labels Combo in a vertical split with the CodeEdit
      setWorkspacePaneProperties(&oPaneData, TRUE, siComboBox.cy, NULL);
      insertWorkspaceWindow(pDocument->hWorkspace, pTargetPane, pDocument->hLabelsCombo, TOP, &oPaneData);
   }
   
   // Search for the Labels pane
   if (findWorkspacePaneByHandle(pDocument->hWorkspace, pDocument->hLabelsCombo, NULL, NULL, pTargetPane))
   {
      /// Add the Variables Combo in a horizontal split with the Labels Combo
      setWorkspacePaneProperties(&oPaneData, TRUE, NULL, 0.5f);
      insertWorkspaceWindow(pDocument->hWorkspace, pTargetPane, pDocument->hVariablesCombo, RIGHT, &oPaneData);
   }

}


/// Function name  : onScriptDocumentCreate
// Description     : Initialises the ScriptDocument controls and the ScriptDocument convenience pointers.
// 
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument data
// HWND              hWnd      : [in] Document window handle
// 
VOID   onScriptDocumentCreate(SCRIPT_DOCUMENT*  pDocument, HWND  hWnd)
{  
   TRY
   {
      CONSOLE_EVENT1(getDocumentFileName(pDocument));

      // Associate data with dialog
      SetWindowLong(hWnd, 0, (LONG)pDocument);
      pDocument->hWnd = hWnd;

      // Create document convenience pointer
      pDocument->pScriptFile = (SCRIPT_FILE*)pDocument->pGameFile;

      /// Create child windows
      createScriptDialogControls(pDocument);
      
      /// Initialise Labels Combo
      appendCustomComboBoxItem(pDocument->hLabelsCombo, loadTempString(IDS_SCRIPT_GLOBAL_SCOPE));
      ComboBox_SetCurSel(pDocument->hLabelsCombo, 0);
      ComboBox_SetMinVisible(pDocument->hLabelsCombo, 6);

      /// Initialise Variables Combo
      appendCustomComboBoxItem(pDocument->hVariablesCombo, loadTempString(IDS_SCRIPT_DOCUMENT_VARIABLES));
      ComboBox_SetCurSel(pDocument->hVariablesCombo, 0);
      ComboBox_SetMinVisible(pDocument->hVariablesCombo, 10);

      /// Display Script
      CodeEdit_SetScriptFile(pDocument->hCodeEdit, pDocument->pScriptFile);

      // Create auto-save timer  (5 minute delay)
      SetTimer(pDocument->hWnd, AUTOSAVE_TICKER, 5 * (60 * 1000), NULL);

      // Show windows
      ShowWindow(pDocument->hLabelsCombo, SW_SHOWNORMAL);
      ShowWindow(pDocument->hVariablesCombo, SW_SHOWNORMAL);
      ShowWindow(pDocument->hCodeEdit, SW_SHOWNORMAL);
   }
   CATCH0("Unable to create document");
}


/// Function name  : onScriptDocumentDestroy
// Description     : Destroy the data contained within the document but not the data structure itself
//
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// 
VOID     onScriptDocumentDestroy(SCRIPT_DOCUMENT*  pDocument)
{
   TRY
   {
      CONSOLE_EVENT1(getDocumentFileName(pDocument));

      // Delete ticker
      KillTimer(pDocument->hWnd, AUTOSAVE_TICKER);
      
      // Destroy workspace
      utilDeleteWindow(pDocument->hWorkspace);

      /// Window data is destroyed by documents control
      #ifdef BUG_FIX
         SetWindowLong(pDocument->hWnd, DWL_USER, NULL);    // BUG:001 caused by deleting the data within this context
         utilDeleteObject(pDocument);
      #endif
   }
   CATCH0("Unable to destroy document");
}


/// Function name  : onScriptDocumentGetMenuItemState
// Description     : Determines whether a toolbar/menu command relating to the document should be enabled or disabled
// 
// SCRIPT_DOCUMENT*  pDocument   : [in]     Script Document to query
// CONST UINT        iCommandID  : [in]     Menu/toolbar Command to query
// UINT*             piState     : [in/out] Combination of MF_ENABLED, MF_DISABLED, MF_CHECKED, MF_UNCHECKED
// 
BOOL  onScriptDocumentGetMenuItemState(SCRIPT_DOCUMENT*  pDocument, CONST UINT  iCommandID, UINT*  piState)
{
   TRY
   {
      // [CHECK] Ensure CodeEdit has focus
      if (GetFocus() != pDocument->hCodeEdit)
         *piState = MF_DISABLED;
      
      // Examine command
      else switch (iCommandID)
      {
      /// [UNDO/REDO] Require empty/full undo queue
      case IDM_EDIT_REDO:  *piState = (RichEdit_CanRedo(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED);   break;
      case IDM_EDIT_UNDO:  *piState = (Edit_CanUndo(pDocument->hCodeEdit)     ? MF_ENABLED : MF_DISABLED);   break;  

      /// [CUT/COPY/DELETE] Requires a text selection
      case IDM_EDIT_CUT:
      case IDM_EDIT_COPY:
      case IDM_EDIT_DELETE:
      case IDM_EDIT_COMMENT:
         *piState = (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED);
         break;

      /// [PASTE / SELECT ALL] Always enabled
      case IDM_EDIT_PASTE:
      case IDM_EDIT_SELECT_ALL:
         *piState = MF_ENABLED;
         break;

      // [UNSUPPORTED] Error
      default:
         VERBOSE(BUG "Unsupported Command");
         break;
      }

      return TRUE;
   }
   CATCH0("Unable to get CodeEdit state")
   
   *piState = MF_DISABLED;
   return TRUE;
}


/// Function name  : onScriptDocumentGotoLabel
// Description     : Scrolls the CodeEdit to the label specified by the command at the caret
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// 
VOID  onScriptDocumentGotoLabel(SCRIPT_DOCUMENT*  pDocument)
{
   CODE_EDIT_LABEL*  pLabel = NULL;
   CONST TCHAR*      szTargetLabel = NULL;
   COMMAND*          pCommand = NULL;        // COMMAND containing the script call
   QUEUE*            pLabelQueue = NULL;
   BOOL              bFound;

   TRY
   {
      CONSOLE_ACTION1(getDocumentFileName(pDocument));

      // Retrieve the COMMAND containing the script call
      pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);
      ASSERT(pCommand);

      // [CHECK] Ensure COMMAND is 'goto label' or 'gosub' and extract label name
      if (isCommandGotoLabel(pCommand, szTargetLabel))
      {
         // Prepare
         pLabelQueue = CodeEdit_GetLabelQueue(pDocument->hCodeEdit);
         bFound      = FALSE;

         // Examine all labels within the document
         while (!bFound AND (pLabel = (CODE_EDIT_LABEL*)popFirstQueueObject(pLabelQueue)))
         {
            /// [LABEL] Scroll CodeEdit to the correct label
            if (bFound = utilCompareStringVariables(pLabel->szName, szTargetLabel))
               CodeEdit_ScrollToLocation(pDocument->hCodeEdit, 0, pLabel->iLineNumber, TRUE);
            
            // Cleanup
            deleteCodeEditLabel(pLabel);
         }

         // Cleanup
         deleteQueue(pLabelQueue);
      }
      return;
   }
   CATCH1("szTargetLabel = '%s'", szTargetLabel);
   debugCommand(pCommand);
   debugQueue(pLabelQueue);
   debugCodeEditLabel(pLabel);
}


/// Function name  : onScriptDocumentHelp
// Description     : Launch the appropriate help page for the currently selected control 
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script Document data
// HWND              hDialog   : [in] Script document window handle
// CONST HELPINFO*   pRequest  : [in] System WM_HELP data
// 
VOID  onScriptDocumentHelp(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog, CONST HELPINFO*  pRequest)
{
   switch (pRequest->iCtrlId)
   {
   case IDC_LABELS_COMBO:     CONSOLE_UI(IDC_LABELS_COMBO, WM_HELP);     displayHelp(TEXT("MSCI_LabelsVariables"));  break;
   case IDC_VARIABLES_COMBO:  CONSOLE_UI(IDC_VARIABLES_COMBO, WM_HELP);  displayHelp(TEXT("MSCI_LabelsVariables"));  break;
   case IDC_CODE_EDIT:        CONSOLE_UI(IDC_CODE_EDIT, WM_HELP);        displayHelp(TEXT("MSCI_Overview"));         break;
   }
}


/// Function name  : onScriptDocumentLoadComplete
// Description     : Recursively opens script-calls, or performs automatic compilation
// 
// SCRIPT_DOCUMENT*     pDocument      : [in] Script document
// DOCUMENT_OPERATION*  pOperationData : [in] Generation Operation Data
// 
VOID   onScriptDocumentLoadComplete(SCRIPT_DOCUMENT*  pDocument, DOCUMENT_OPERATION*  pOperationData)
{
   SCRIPT_DEPENDENCY  *pDependency = NULL;   // Depdency being loaded
   LOADING_OPTIONS     oLoadingOptions;      // Advanced load/save options
   CODE_EDIT_SEARCH    oSearch;                 // FindText options
   ERROR_STACK        *pError;
   AVL_TREE           *pDependenciesTree = 0;   // Script Dependencies tree
   TCHAR              *szScriptPath = 0,        // Full path of script being tested/loaded
                      *szFolder = 0;      // Folder containing script being tested

   TRY
   {
      // [TRACK]
      CONSOLE_EVENT_BOLD1(getDocumentFileName(pDocument));
      CONSOLE("Script '%s' loaded successfully", pDocument->szFullPath);
      debugScriptDocument(pDocument);

      // Prepare
      szFolder = utilDuplicateFolderPath(getDocumentPath(pDocument));

      /// [MODIFIED on LOAD] 
      if (pDocument->pScriptFile->bModifiedOnLoad)
         setDocumentModifiedFlag(pDocument, TRUE);
      
      /// [RECURSION] Are we opening script dependencies?
      if (pOperationData->oAdvanced.iRecursionDepth > 0)
      {
         CONSOLE("Recursively opening scripts to a depth of %d", pOperationData->oAdvanced.iRecursionDepth);

         // Generate dependencies tree
         pDependenciesTree = CodeEdit_GetScriptDependencyTree(pDocument->hCodeEdit);

         // Decrease recursion depth
         oLoadingOptions = pOperationData->oAdvanced;
         oLoadingOptions.iRecursionDepth--;

         // Iterate through dependencies
         for (UINT  iIndex = 0; findObjectInAVLTreeByIndex(pDependenciesTree, iIndex, (LPARAM&)pDependency); iIndex++)
         {
            /// Load script dependency
            if (!commandLoadScriptDependency(getMainWindowData(), szFolder, pDependency, FALSE, &oLoadingOptions))
               // [WARNING] "Cannot find script dependency '%s' in '%s'"
               displayError(pError = generateDualWarning(HERE(IDS_SCRIPT_DEPENDENCY_MISSING), pDependency->szScriptName, szFolder));
         }

         // Cleanup
         deleteAVLTree(pDependenciesTree);
      }
      /// [GENERATION TEST] Are we performing a compilation test?
      else if (pOperationData->oAdvanced.eCompilerTest == ODT_GENERATION)
      {
         CONSOLE("Performing ODT_GENERATION compiler test");

         /// Preserve document filename but save into a 'Validation' sub-folder and ensure extension is XML
         szScriptPath = utilCreateStringf(MAX_PATH, TEXT("%sCode.Validation\\%s"), szFolder, getDocumentFileName(pDocument));
         PathRenameExtension(szScriptPath, TEXT(".xml"));
         setDocumentPath(pDocument, szScriptPath);

         /// Save document, Close if successful
         commandSaveDocument(getMainWindowData(), pDocument, TRUE, &pOperationData->oAdvanced);    // Pass existing batch file data, if any

         // Cleanup
         utilDeleteString(szScriptPath);
      }
      /// [HIGHLIGHT] Perform 'FindText' on desired highlight phrase
      else if (pOperationData->oAdvanced.bHighlight) 
      {
         // Prepare
         oSearch.eFlags    = CSF_FROM_TOP;
         oSearch.szSearch  = pOperationData->oAdvanced.szSearchText;
         oSearch.szReplace = NULL;
         
         /// Highlight/Display content
         if (lstrlen(oSearch.szSearch))
            CodeEdit_FindText(pDocument->hCodeEdit, &oSearch);
         else
         {
            CodeEdit_ScrollToLocation(pDocument->hCodeEdit, 0, pOperationData->oAdvanced.iLineNumber, FALSE);
            CodeEdit_SelectLine(pDocument->hCodeEdit, pOperationData->oAdvanced.iLineNumber);
         }  
      }

      // Cleanup
      utilDeleteString(szFolder);
      return;
   }
   CATCH4("iRecursionDepth=%d  eCompilerTest=%d  szScriptPath='%s'  szFolder='%s'", pOperationData->oAdvanced.iRecursionDepth, pOperationData->oAdvanced.eCompilerTest, szScriptPath, szFolder);
   debugTree(pDependenciesTree);
   debugScriptDependency(pDependency);
}


/// Function name  : onScriptDocumentLookupCommand
// Description     : Displays MSCI reference URL
// 
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument
// 
VOID  onScriptDocumentLookupCommand(SCRIPT_DOCUMENT*  pDocument)
{
   COMMAND*    pCommand = NULL;      // CodeEdit line COMMAND
   
   TRY
   {
      CONSOLE_ACTION();
      CONSOLE("Launching URL of MSCI command in document '%s'", pDocument->szFullPath);

      // Lookup COMMAND
      pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);

      // [CHECK] Ensure command has URL
      if (pCommand AND isCommandReferenceURLPresent(pCommand->pSyntax))
         /// [FOUND] Launch MSCI reference URL
         utilLaunchURL(getAppWindow(), pCommand->pSyntax->szReferenceURL, SW_SHOWMAXIMIZED);

      return;
   }
   CATCH0("Unable to lookup command");
   debugCommand(pCommand);
}


/// Function name  : onScriptDocumentLoseFocus
// Description     : Destroy the 'Current scope' ticker
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// HWND              hDialog   : [in] 
// 
VOID  onScriptDocumentLoseFocus(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog)
{
      
   // Destroy labels refresh timer + Refresh Toolbar
   //KillTimer(pDocument->hWnd, AUTOSAVE_TICKER);
   //updateMainWindowToolBar(getMainWindowData());
}


/// Function name  : onScriptDocumentNotify
// Description     : WM_NOTIFY handler for documents
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// NMHDR*            pMessage  : [in] 
//
// Return Type : TRUE if processed, FALSE otherwise
// 
BOOL   onScriptDocumentNotify(SCRIPT_DOCUMENT*  pDocument, NMHDR*  pMessage)
{
   // [CUSTOM DRAW]
   /*if (pMessage->code == NM_CUSTOMDRAW)
   {
      CONSOLE("Custom draw hwnd = %08u", pMessage->hwndFrom);
   }*/

   return FALSE;
}


/// Function name  : onScriptDocumentOpenTargetScript
// Description     : Loads the script specified in the script call command at the caret
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// 
VOID  onScriptDocumentOpenTargetScript(SCRIPT_DOCUMENT*  pDocument)
{
   SCRIPT_DEPENDENCY  oDependency;
   const TCHAR*       szScript;
   COMMAND*           pCommand = NULL;    // COMMAND containing the script call
   TCHAR*             szFolder = NULL;    // Full path of the target script

   TRY
   {
      // [TRACK]
      CONSOLE_ACTION();

      // Prepare
      pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);
      szFolder = utilDuplicateFolderPath(pDocument->szFullPath);

      // Extract script-name
      if (findScriptCallTargetInCommand(pCommand, szScript))
      {
         // Prepare
         StringCchCopy(oDependency.szScriptName, 128, szScript);

         /// Attempt to load script (as PCK/XML)
         if (!commandLoadScriptDependency(getMainWindowData(), szFolder, &oDependency, TRUE, NULL))
            // [ERROR] "The script dependency '%s' could not be found in '%s'"
            displayMessageDialogf(NULL, IDS_GENERAL_DEPENDENCY_NOT_FOUND, MDF_OK WITH MDF_ERROR, oDependency.szScriptName, szFolder);
      }
         
      // Cleanup
      utilDeleteString(szFolder);
      return;
   }
   CATCH1("Unable to open target script: szFolder='%s'", szFolder);
   debugCommand(pCommand);
}


/// Function name  : onScriptDocumentPreferencesChanged
// Description     : Refresh the CodeEdit
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// 
VOID   onScriptDocumentPreferencesChanged(SCRIPT_DOCUMENT*  pDocument)
{
   TRY
   {
      CONSOLE_EVENT();

      /// Pass new preferences to the CodeEdit
      CodeEdit_SetPreferences(pDocument->hCodeEdit, getAppPreferences());
   }
   CATCH0("Unable to set preferences");
}


/// Function name  : onScriptDocumentReceiveFocus
// Description     : Create the 'Current scope' timer
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// HWND              hDialog   : [in] 
// 
VOID  onScriptDocumentReceiveFocus(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog)
{
   CONSOLE_EVENT1(getDocumentFileName(pDocument));
   CONSOLE("Passing input focus to the CodeEdit of document '%s'", pDocument->szFullPath);

   // Setup labels refresh timer
   //SetTimer(pDocument->hWnd, AUTOSAVE_TICKER, 2000, NULL);

   // Set focus to the CodeEdit
   SetFocus(pDocument->hCodeEdit);

   // Refresh Toolbar
   //updateMainWindowToolBar(getMainWindowData());
}


/// Function name  : onScriptDocumentResize
// Description     : Resizes a script document and repositions it's child windows
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// CONST SIZE*       pNewSize  : [in] New window size
// 
VOID   onScriptDocumentResize(SCRIPT_DOCUMENT*  pDocument, CONST SIZE*  pNewSize)
{
   // Resize workspace
   SetWindowPos(pDocument->hWorkspace, NULL, NULL, NULL, pNewSize->cx, pNewSize->cy, SWP_NOMOVE WITH SWP_NOZORDER);
}


/// Function name  : onScriptDocumentRequestArguments
// Description     : Inserts default script-call arguments at the caret in the CodeEdit.  Used for script-call auto-complete.
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Document
// CONST COMMAND*    pCommand  : [in] ScriptCall command
// 
VOID  onScriptDocumentRequestArguments(SCRIPT_DOCUMENT*  pDocument, CONST COMMAND*  pCommand)
{
   SCRIPT_FILE*  pTargetScript = NULL;
   ERROR_QUEUE*  pErrorQueue = NULL;
   ARGUMENT*     pArgument = NULL;
   TCHAR*        szOutput = NULL;

   TRY
   {
      CONSOLE_EVENT();

      // Prepare
      szOutput = utilCreateEmptyString(LINE_LENGTH);

      // [CHECK] Attempt to load the script properties into a new ScriptFile
      if (loadScriptCallCommandTargetScript(pDocument->pScriptFile, pCommand, pDocument->hWnd, pTargetScript, pErrorQueue = createErrorQueue()))
      {
         // [SUCCESS] Generate arguments string
         for (UINT  iIndex = 0; findArgumentInScriptFileByIndex(pTargetScript, iIndex, pArgument); iIndex++)
            utilStringCchCatf(szOutput, LINE_LENGTH, TEXT(" %s=%s"), pArgument->szName, identifyParameterSyntaxDefaultValue(pArgument->eType));
       
         // Insert into CodeEdit
         StringCchCat(szOutput, LINE_LENGTH, TEXT(" "));
         CodeEdit_InsertTextAtCaret(pDocument->hCodeEdit, szOutput);

         // Cleanup
         deleteScriptFile(pTargetScript);
      }

      // Cleanup
      utilDeleteString(szOutput);
      deleteErrorQueue(pErrorQueue);
      return;
   }
   CATCH1("Unable to insert ScriptCall arguments: szOutput='%s'", szOutput);
   debugScriptFile(pTargetScript);
   debugCommand(pCommand);
}


/// Function name  : onScriptDocumentSaveComplete
// Description     : Marks the document as 'un-modified' if successful
// 
// SCRIPT_DOCUMENT*     pDocument      : [in] Script document
// DOCUMENT_OPERATION*  pOperationData : [in] Generation Operation Data
// 
VOID   onScriptDocumentSaveComplete(SCRIPT_DOCUMENT*  pDocument, DOCUMENT_OPERATION*  pOperationData)
{
   LOADING_OPTIONS  oOptions;          // Advance loading options

   TRY
   {
      /// [SUCCESSFUL] Document saved successfully
      if (isOperationSuccessful(pOperationData))
      {
         /// [UN-MODIFIED] Remove 'modified' flag
         setDocumentModifiedFlag(pDocument, FALSE);

         // [COMPILER TEST] Validate the generated document
         if (pOperationData->oAdvanced.eCompilerTest == ODT_GENERATION)
         {
            // Prepare
            oOptions = pOperationData->oAdvanced;

            // [VALIDATE] Switch to validation mode
            oOptions.eCompilerTest = ODT_VALIDATION;

            /// [SINGLE] Re-open original file in validation mode
            commandLoadDocument(getMainWindowData(), FIF_SCRIPT, oOptions.szOriginalPath, TRUE, &oOptions);
         }
      }
      /// [FAILED] 
      else 
      {
         // [AUTO-VERSION] Decrement script version
         if (getAppPreferences()->bVersionIncrement)
            pDocument->pScriptFile->iVersion--;

         // [CHECK] Are we batch testing?
         if (pOperationData->oAdvanced.bBatchCompilerTest)
            /// [BATCH TESTING] Stop batch test
            commandScriptValidationBatchTest(getMainWindowData(), BTC_STOP);
      }

      // Refresh CodeEdit
      InvalidateRect(pDocument->hCodeEdit, NULL, FALSE);

      // [AUTO-VERSION] Refresh properties
      if (getAppPreferences()->bVersionIncrement && pDocument == getActiveDocument())
         sendDocumentUpdated(AW_PROPERTIES);
      return;
   }
   CATCH0("Unable to complete save");
   debugOperationData(pOperationData);
}


/// Function name  : onScriptDocumentScopeChange
// Description     : Updates the scope combobox
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// CODE_EDIT_LABEL*  pNewScope : [in] New scope
// 
VOID  onScriptDocumentScopeChange(SCRIPT_DOCUMENT*  pDocument, CODE_EDIT_LABEL*  pNewScope)
{
   // Update labels and display current scope
   updateScriptDocumentLabelsCombo(pDocument);
}


/// Function name  : onScriptDocumentSelectionChange
// Description     : Update the main window's toolbar
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script Document
// 
VOID  onScriptDocumentSelectionChange(SCRIPT_DOCUMENT*  pDocument)
{
   // Update main window toolbar to reflect current selection
   updateMainWindowToolBar(getMainWindowData());
}


/// Function name  : onScriptDocumentTextChange
// Description     : Inform main window the document has changed
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// 
VOID  onScriptDocumentTextChange(SCRIPT_DOCUMENT*  pDocument)
{
   // Inform main window that the underlying document data has changed
   sendDocumentUpdated(AW_DOCUMENTS_CTRL);
}


/// Function name  : onScriptDocumentPropertyChanged
// Description     : Refresh CodeEdit when arguments change
//
// SCRIPT_DOCUMENT*  pDocument  : [in] Document that has been updated
// CONST UINT        iControlID : [in] ID of the control responsible for the change
// 
VOID  onScriptDocumentPropertyChanged(SCRIPT_DOCUMENT*  pDocument, CONST UINT  iControlID)
{
   SCRIPT_FILE*  pScriptFile = pDocument->pScriptFile;

   CONSOLE_EVENT();

   // [ARGUMENTS CHANGED] Refresh CodeEdit
   if (iControlID == IDC_ARGUMENTS_LIST)
      InvalidateWindow(pDocument->hCodeEdit, FALSE);

   // [DEBUG]
   switch (iControlID)
   {
   case IDC_SCRIPT_NAME:            CONSOLE("Script name changed to '%s'",    pScriptFile->szScriptname);                              break;
   case IDC_SCRIPT_DESCRIPTION:     CONSOLE("Description changed to '%s'",    pScriptFile->szDescription);                             break;
   case IDC_SCRIPT_COMMAND:         CONSOLE("Command ID changed to '%s'",     pScriptFile->szCommandID);                               break;
   case IDC_SCRIPT_VERSION:         CONSOLE("Version changed to %d",          pScriptFile->iVersion);                                  break;
   case IDC_SCRIPT_ENGINE_VERSION:  CONSOLE("EngineVersion changed to '%s'",  identifyGameVersionString(pScriptFile->eGameVersion));   break;
   case IDC_SCRIPT_FOLDER:          CONSOLE("Path changed to '%s'",           pScriptFile->szFullPath);                                break;
   }
}

/// Function name  : onScriptDocumentValidationComplete
// Description     : Moves to the next script in the batch test.
///                                       Note: When validation is successful, the document does not actually exist
// 
// SCRIPT_DOCUMENT*     pDocument      : [in] Script Document, if failed, otherwise NULL
// DOCUMENT_OPERATION*  pOperationData : [in] Generation Operation Data
// 
VOID   onScriptDocumentValidationComplete(SCRIPT_DOCUMENT*  pDocument, DOCUMENT_OPERATION*  pOperationData)
{
   
   /// [SUCCESSFUL] Validation successful
   if (isOperationSuccessful(pOperationData))
   {
      // [CHECK] Document does not actually exist
      ASSERT(pDocument == NULL);

      // [CHECK] Are we batch testing?
      if (pOperationData->oAdvanced.bBatchCompilerTest)
         /// [BATCH TESTING] Load the next document in the sequence
         commandScriptValidationBatchTest(getMainWindowData(), BTC_NEXT_FILE);
   }
   /// [FAILED] 
   // Do nothing
}


/// Function name  : onScriptDocumentViewLanguageString
// Description     : Display the string referenced by the command on the current line
// 
// SCRIPT_DOCUMENT*    pDocument   : [in] ScriptDocument
// 
VOID  onScriptDocumentViewLanguageString(SCRIPT_DOCUMENT*  pDocument)
{
   GAME_STRING*  pDependency = NULL;

   CONSOLE_ACTION();

   // [CHECK] Lookup Dependency
   if (pDependency = CodeEdit_GetCaretGameString(pDocument->hCodeEdit, getActiveProjectFile()))
   {
      CONSOLE("Displaying GameString (%d:%d) : '%s'", pDependency->iPageID, pDependency->iID, pDependency->szText);

      /// Load/Display game strings
      onMainWindowDataGameStrings(getMainWindowData());

      // Select desired GameString
      displayLanguageDocumentGameString(getActiveLanguageDocument(), pDependency);

      /// REM: Pages don't necessarily correspond to specific files :(
      /*LOADING_OPTIONS  oOptions;
      oOptions.iPageID   = pDependency->iPageID;
      oOptions.iStringID = pDependency->iID;
      
      commandLoadDocument(getMainWindowData(), FIF_LANGUAGE, path, TRUE, &oOptions);*/
   }
}


/// Function name  : onScriptDocumentViewError
// Description     : Display the error associated with the line used to invoke the context menu
// 
// SCRIPT_DOCUMENT*    pDocument   : [in] ScriptDocument
// 
VOID  onScriptDocumentViewError(SCRIPT_DOCUMENT*  pDocument)
{
   ERROR_QUEUE*  pErrorQueue = NULL;    // ErrorQueue

   TRY
   {
      // [TRACK]
      CONSOLE_ACTION();

      // Prepare
      pErrorQueue = CodeEdit_GetCaretLineError(pDocument->hCodeEdit);

      // [CHECK] Are there multiple errors?
      if (getQueueItemCount(pErrorQueue) <= 1)
         // [SINGLE] Display stack dialog
         displayErrorMessageDialog(NULL, firstErrorQueue(pErrorQueue), loadTempStringf(IDS_SCRIPT_COMPILER_ERROR, TEXT("")), MDF_OK);
      else
         // [MULTIPLE] Display queue dialog
         displayErrorQueueDialog(NULL, pErrorQueue, loadTempStringf(IDS_SCRIPT_COMPILER_ERROR, identifyErrorTypeString(firstErrorQueue(pErrorQueue)->eType)) );

      return;
   }
   CATCH0("Unable to view error");
   debugQueue(pErrorQueue);
}


/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          WINDOW PROCEDURE
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : wndprocScriptDocument
// Description     : ScriptDocument window procedure
//
//
LRESULT   wndprocScriptDocument(HWND  hDialog, UINT  iMessage, WPARAM  wParam, LPARAM  lParam)
{
   DOCUMENT_OPERATION*  pOperationData;
   SCRIPT_DOCUMENT*     pDocument;
   MEASUREITEMSTRUCT*   pItemSize;
   CREATESTRUCT*        pCreationData;
   POINT                ptCursor;
   SIZE                 siWindow;
   LRESULT              iResult = 0;

   TRY
   {
      // Get document data
      pDocument = (SCRIPT_DOCUMENT*)GetWindowLong(hDialog, 0);

      // Examine message
      switch (iMessage)
      {
      /// [CREATE] 
      case WM_CREATE:
         // Prepare
         pCreationData = (CREATESTRUCT*)lParam;
         pDocument = (SCRIPT_DOCUMENT*)pCreationData->lpCreateParams;

         // Init dialog
         onScriptDocumentCreate(pDocument, hDialog);
         break;

      /// [DESTROY] - Delete document data
      case WM_DESTROY:
         onScriptDocumentDestroy(pDocument);
         break;

      /// [COMMAND PROCESSING]
      case WM_COMMAND:
         if (!onScriptDocumentCommand(pDocument, LOWORD(wParam), HIWORD(wParam)))
            // [UNHANDLED] Call default window proc
            iResult = DefWindowProc(hDialog, iMessage, wParam, lParam);
         break;

      /// [NOTIFICATION]
      case WM_NOTIFY:
         if (!onScriptDocumentNotify(pDocument, (NMHDR*)lParam))
            // [UNHANDLED] Call default window proc
            iResult = DefWindowProc(hDialog, iMessage, wParam, lParam);
         break;

      /// [RESIZE] - Resize tab to the size of the tab control
      case WM_SIZE:
         siWindow.cx = LOWORD(lParam);
         siWindow.cy = HIWORD(lParam);
         
         onScriptDocumentResize(pDocument, &siWindow);
         break;

      /// [CONTEXT MENU]
      case WM_CONTEXTMENU:
         ptCursor.x = GET_X_LPARAM(lParam);
         ptCursor.y = GET_Y_LPARAM(lParam);
         onScriptDocumentContextMenu(pDocument, hDialog, &ptCursor, (HWND)wParam);
         break;

      /// [MENU ITEM HOVER] Forward messages from CodeEdit up the chain to the Main window
      case WM_MENUSELECT:
         sendAppMessage(AW_MAIN, WM_MENUSELECT, wParam, lParam);
         break;

      /// [RECEIVE/LOSE FOCUS]
      case WM_SETFOCUS:    onScriptDocumentReceiveFocus(pDocument, hDialog);  break;
      case WM_KILLFOCUS:   onScriptDocumentLoseFocus(pDocument, hDialog);     break;

      /// [TIMER]
      case WM_TIMER:
         if (wParam == AUTOSAVE_TICKER)
            onScriptDocumentAutoSave(pDocument);
         break;

      /// [CONTEXT HELP]
      case WM_HELP:
         onScriptDocumentHelp(pDocument, hDialog, (HELPINFO*)lParam);
         break;

      /// [KEYBOARD INPUT] Request keyboard input
      case WM_GETDLGCODE:
         iResult = DLGC_WANTALLKEYS;
         break;

      /// [CUSTOM MENU/CUSTOM COMBO]
      case WM_DRAWITEM:    onWindow_DrawItem((DRAWITEMSTRUCT*)lParam);                     break;
      case WM_DELETEITEM:  onWindow_DeleteItem((DELETEITEMSTRUCT*)lParam);                 break;
      case WM_MEASUREITEM: pItemSize = (MEASUREITEMSTRUCT*)lParam; 
                           pItemSize->CtlType == ODT_COMBOBOX ? onWindow_MeasureComboBox(pItemSize, ITS_MEDIUM, ITS_MEDIUM) : onWindow_MeasureItem(hDialog, pItemSize);  break;

      /// [THEME CHANGED]
      case WM_THEMECHANGED:  setWorkspaceBackgroundColour(pDocument->hWorkspace, getTabThemeColour());  break;

      /// [DOCUMENT LOADED/SAVED]
      case UN_OPERATION_COMPLETE:
         // Prepare
         pOperationData = (DOCUMENT_OPERATION*)lParam;

         // Examine operation type
         if (pOperationData->eType == OT_LOAD_SCRIPT_FILE)
            onScriptDocumentLoadComplete(pDocument, pOperationData);
         else if (pOperationData->eType == OT_SAVE_SCRIPT_FILE)
            onScriptDocumentSaveComplete(pDocument, pOperationData);
         else if (pOperationData->eType == OT_VALIDATE_SCRIPT_FILE)
            onScriptDocumentValidationComplete(pDocument, pOperationData);
         break;

      /// [DOCUMENT PROPERTY CHANGED]
      case UN_PROPERTY_UPDATED:
         onScriptDocumentPropertyChanged(pDocument, wParam);
         break;

      /// [GET MENU CMD STATE]
      case UM_GET_MENU_ITEM_STATE:
         iResult = onScriptDocumentGetMenuItemState(pDocument, wParam, (UINT*)lParam);
         break;

      /// [INSERT RESULT] Forward to CodeEdit
      case UM_INSERT_TEXT_AT_CARET:
         CodeEdit_InsertTextAtCaret(pDocument->hCodeEdit, (CONST TCHAR*)lParam);
         break;

      /// [CODE-EDIT CHANGED]
      case UN_CODE_EDIT_CHANGED:
         // [SELECTION CHANGED]
         if (wParam INCLUDES CCF_SELECTION_CHANGED)
            onScriptDocumentSelectionChange(pDocument);

         // [TEXT CHANGED]
         if (wParam INCLUDES CCF_TEXT_CHANGED)
            onScriptDocumentTextChange(pDocument);

         // [SCOPE CHANGED]
         if (wParam INCLUDES CCF_SCOPE_CHANGED)
            onScriptDocumentScopeChange(pDocument, (CODE_EDIT_LABEL*)lParam);
         break;

      /// [CODE-EDIT SCRIPT-ARGUMENTS]
      case UN_CODE_EDIT_REQUEST_ARGUMENTS:
         onScriptDocumentRequestArguments(pDocument, (COMMAND*)lParam);
         break;

      /// [PREFERENCES CHANGED]
      case UN_PREFERENCES_CHANGED:
         onScriptDocumentPreferencesChanged(pDocument);
         break;

      // [UNHANDLED]
      default:
         iResult = DefWindowProc(hDialog, iMessage, wParam, lParam);
         break;
      }

      // [FOCUS HANDLER]
      updateMainWindowToolBar(iMessage, wParam, lParam);

      // Return result
      return iResult;
   }
   /// [EXCEPTION HANDLER]
   CATCH3("iMessage=%s  wParam=%d  lParam=%d", identifyMessage(iMessage), wParam, lParam);
   return 0;
}


