//
// AVL Tree.cpp : An AVLTree capable of holding any object and the ability to sort it's objects by up to two properties.
//                 There's also the facility to run custom operations on each node in the tree.
//
// NB: Best viewed with tab size of 3 characters and Visual Studio's 'XML Doc Comment' syntax colouring
//         set to a colour that highly contrasts the 'C/C++ comment' syntax colouring
// 

#include "stdafx.h"

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                            MACROS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Name: extractObjectProperty
//  Descrpition: Extracts a property from a TreeNode
// 
// AVL_TREE*          pTree      : [in] Tree containing the object
// LPARAM             pObject    : [in] Object to extract the property from
// AVL_TREE_SORT_KEY  eProperty  : [in] Property to extract
//
#define    extractObjectProperty(pTree,pObject,eProperty)        (*pTree->pfnExtractValue)(pObject, eProperty)

/// Name: findSingleChildNode
//  Descrpition: Convenience macro for specifying the one valid child of a node  (Used by the removeByValue function)
// 
// AVL_TREE_NODE*     pTree      : [in] Tree node with ONE valid child
//
#define    findSingleChildNode(pParent)                          (pParent->pLeft ? pParent->pLeft : pParent->pRight)

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                        CREATION / DESTRUCTION
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : createAVLTree
// Description     : Creates and AVL Tree containing the desired type of objects, sorted by up to two properties
// 
// AVL_NODE_EXTRACTOR        pfnExtractValue     : [in]           TreeNode value extraction function, for performing comparisons
// DESTRUCTOR                pfnDeleteNode       : [in][optional] TreeNode deletion function. If this is not specified then the objects will not be destroyed with the tree
// CONST AVL_TREE_KEY*       ePrimaryKey         : [in]           Primary sorting property
// CONST AVL_TREE_KEY*       eSecondaryKey       : [in][optional] Secondary sorting property
// CONST AVL_TREE_KEY*       ePrimarySortOrder   : [in][optional] Tertiary sorting property
// 
// Return Value   : New AVLTree, you are responsible for destroying it
// 
AVL_TREE*  createAVLTree(AVL_NODE_EXTRACTOR  pfnExtractValue, DESTRUCTOR  pfnDeleteNode, AVL_TREE_KEY*  pPrimaryKey, AVL_TREE_KEY*  pSecondaryKey, AVL_TREE_KEY*  pTertiaryKey)
{
   AVL_TREE*   pTree;

   // [CHECK] Ensure tree has at least one key
   ASSERT(pPrimaryKey != NULL);

   // Create empty object
   pTree = utilCreateEmptyObject(AVL_TREE);

   // Store keys and functions
   pTree->pSortKeys[0]    = pPrimaryKey;
   pTree->pSortKeys[1]    = pSecondaryKey;
   pTree->pSortKeys[2]    = pTertiaryKey;
   pTree->pfnExtractValue = pfnExtractValue;
   pTree->pfnDeleteNode   = pfnDeleteNode;

   // Calculate key count
   pTree->iKeyCount = (pTertiaryKey ? 3 : (pSecondaryKey ? 2 : 1));

   // Return new object
   return pTree;
}


/// Function name  : createAVLTreeNode
// Description     : Creates a new AVLTree Node and increments the tree's object counter.
///                              NB: Only the link from NODE -> PARENT is created. Link from PARENT -> NODE is generated by caller.
// 
// AVL_TREE*       pTree   : [in] AVL-Tree the node is being attached to
// AVL_TREE_NODE*  pParent : [in] Parent for the new node
// LPARAM          pData   : [in] Pointer to a compatible object
// 
// Return Value   : New AVLTreeNode, you are responsible for destroying it
// 
AVL_TREE_NODE*  createAVLTreeNode(AVL_TREE*  pTree, AVL_TREE_NODE*  pParent, LPARAM  pData)
{
   AVL_TREE_NODE*  pNode;

   // Create new object
   pNode = utilCreateEmptyObject(AVL_TREE_NODE);

   // Set properties
   pNode->pData   = pData;
   pNode->pParent = pParent;
   pNode->iHeight = 1;

   // Increment object count
   pTree->iCount++;

   // Return new node
   return pNode;
}


/// Function name  : createAVLTreeSortKey
// Description     : Creates an AVLTree sort key
// 
// CONST AVL_TREE_SORT_KEY       eSorting    : [in] Sort property
// CONST AVL_TREE_ORDERING       eDirection  : [in] Direction of sort
// 
// Return Value   : New AVLTree sort key
// 
BearScriptAPI
AVL_TREE_KEY*  createAVLTreeSortKey(CONST AVL_TREE_SORT_KEY  eSorting, CONST AVL_TREE_ORDERING  eDirection)
{
   AVL_TREE_KEY*  pSortKey;   // New key

   // Create object
   pSortKey = utilCreateEmptyObject(AVL_TREE_KEY);

   // Set properties
   pSortKey->eSorting   = eSorting;
   pSortKey->eDirection = eDirection;
   pSortKey->eType      = identifyAVLTreePropertyType(eSorting);
   
   // Return sort key
   return pSortKey;
}


/// Function name  : createAVLTreeSortKeyEx
// Description     : Creates an AVLTree sort key using a custom type
// 
// CONST AVL_TREE_SORT_KEY       eSorting    : [in] Sort property
// CONST AVL_TREE_ORDERING       eDirection  : [in] Direction of sort
// CONST AVL_TREE_PROPERTY_TYPE  eType       : [in] Whether property is integer or string
// 
// Return Value   : New AVLTree sort key
// 
BearScriptAPI
AVL_TREE_KEY*  createAVLTreeSortKeyEx(CONST AVL_TREE_SORT_KEY  eSorting, CONST AVL_TREE_ORDERING  eDirection, CONST AVL_TREE_PROPERTY_TYPE  eType)
{
   AVL_TREE_KEY*  pSortKey;   // New key

   // Create object
   pSortKey = utilCreateEmptyObject(AVL_TREE_KEY);

   // Set properties
   pSortKey->eSorting   = eSorting;
   pSortKey->eDirection = eDirection;
   pSortKey->eType      = eType;
   
   // Return sort key
   return pSortKey;
}


/// Function name  : duplicateAVLTree
// Description     : Duplicate an AVL tree, performing a shallow copy of objects
// 
// AVL_NODE_EXTRACTOR        pfnExtractValue     : [in]           TreeNode value extraction function, for performing comparisons
// DESTRUCTOR                pfnDeleteNode       : [in][optional] TreeNode deletion function. If this is not specified then the objects will not be destroyed with the tree
// CONST AVL_TREE_KEY*       ePrimaryKey         : [in]           Primary sorting property
// CONST AVL_TREE_KEY*       eSecondaryKey       : [in][optional] Secondary sorting property
// CONST AVL_TREE_KEY*       ePrimarySortOrder   : [in][optional] Tertiary sorting property
// 
// Return Value   : New AVLTree, you are responsible for destroying it
// 
BearScriptAPI 
AVL_TREE*  duplicateAVLTree(AVL_TREE*  pTree, AVL_TREE_KEY*  pNewPrimaryKey, AVL_TREE_KEY*  pNewSecondaryKey, AVL_TREE_KEY*  pNewTertiaryKey)
{
   AVL_TREE_OPERATION*  pOperationData;
   AVL_TREE*            pNewTree;

   /// Create new tree
   pNewTree = createAVLTree(pTree->pfnExtractValue, pTree->pfnDeleteNode, pNewPrimaryKey, pNewSecondaryKey, pNewTertiaryKey);

   // Prepare replication operation
   pOperationData              = createAVLTreeOperation(treeprocReplicateAVLTreeNode, ATT_INORDER);
   pOperationData->pOutputTree = pNewTree;

   /// Copy objects into new tree
   performOperationOnAVLTree(pTree, pOperationData);

   // [CHECK] Index tree if appropirate
   if (pTree->bIndexed)
      performAVLTreeIndexing(pNewTree);

   // Cleanup and return new object
   deleteAVLTreeOperation(pOperationData);
   return pNewTree;
}

/// Function name  : deleteAVLTree
// Description     : Destroys an AVLTree and the nodes it contains.  (If a destruction function is present, node data is already destroyed)
// 
// AVL_TREE*  pTree : [in] AVLTree to destroy
// 
BearScriptAPI
VOID  deleteAVLTree(AVL_TREE*  &pTree)
{
   if (pTree)
   {
      // Delete sort keys
      for (UINT iKey = 0; iKey < pTree->iKeyCount; iKey++)
         deleteAVLTreeSortKey(pTree->pSortKeys[iKey]);

      // Delete contents (if any)
      if (pTree->pRoot)
         deleteAVLTreeNode(pTree, pTree->pRoot, TRUE);

      // Delete calling object
      utilDeleteObject(pTree);
   }
}


/// Function name  : deleteAVLTreeContents
// Description     : Destroys the nodes in an AVLTree. (If a destruction function is present, node data is already destroyed)
// 
// AVL_TREE*  pTree : [in] AVLTree to destroy
// 
BearScriptAPI
VOID  deleteAVLTreeContents(AVL_TREE*  &pTree)
{
   // Delete contents (if any)
   if (pTree AND pTree->pRoot)
      deleteAVLTreeNode(pTree, pTree->pRoot, TRUE);
}


/// Function name  : deleteAVLTreeNode
// Description     : Destroys an AVLTree Node and decrements the tree's object counter
// 
// AVL_TREE*       pTree     : [in] Tree that contains the node
// AVL_TREE_NODE* &pNode     : [in] Node to destroy
// CONST BOOL      bContents : [in] Whether to also destroy the object within the node
// 
BearScriptAPI
VOID  deleteAVLTreeNode(AVL_TREE*  pTree, AVL_TREE_NODE*  &pNode, CONST BOOL  bContents)
{
   // [LEFT-CHILD] Delete left sub-tree
   if (pNode->pLeft)
      deleteAVLTreeNode(pTree, pNode->pLeft, bContents);

   // [RIGHT-CHILD] Delete right sub-tree
   if (pNode->pRight)
      deleteAVLTreeNode(pTree, pNode->pRight, bContents);

   // [OPTIONAL] Delete contents, if desired
   if (bContents AND pTree->pfnDeleteNode)
      (*pTree->pfnDeleteNode)(pNode->pData);

   // Delete node
   pTree->iCount--;
   utilDeleteObject(pNode);
}


/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                              HELPERS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : attachAVLTreeNodeToParent
// Description     : Attaches one node to another in a specified manner, or defines a node as the new ROOT
// 
// AVL_TREE*               pTree    : [in] Tree containing both the nodes
// AVL_TREE_NODE*          pParent  : [in] Parent node. Must be NULL if linkage is ROOT.
// AVL_TREE_NODE*          pNode    : [in] Child node
// CONST AVL_TREE_LINKAGE  eLinkage : [in] Whether to connect node as left/right child or use as the new tree ROOT
// 
VOID  attachAVLTreeNodeToParent(AVL_TREE*  pTree, AVL_TREE_NODE*  pParent, AVL_TREE_NODE*  pNode, CONST AVL_TREE_LINKAGE  eLinkage)
{
   switch (eLinkage)
   {
   // [LEFT] Attach as LEFT CHILD
   case ATL_LEFT:
      pParent->pLeft = pNode;
      pNode->pParent = pParent;
      break;

   // [RIGHT] Attach as RIGHT CHILD
   case ATL_RIGHT:
      pParent->pRight = pNode;
      pNode->pParent  = pParent;
      break;

   // [ROOT] Attach to TREE ROOT
   case ATL_ROOT:
      // [CHECK] Parent should be NULL
      ASSERT(pParent == NULL);

      // Define new ROOT
      pTree->pRoot   = pNode;
      pNode->pParent = NULL;
   }
}

/// Function name  : calculateAVLTreeNodeBalance
// Description     : Calculates the balance factor of a node 
// 
// CONST AVL_TREE_NODE*  pNode : [in] Target node
// 
// Return Value   : (# LEFT children) minus (# RIGHT children)
// 
INT  calculateAVLTreeNodeBalance(CONST AVL_TREE_NODE*  pNode)
{
   // Return: Height(LEFT) - Height(RIGHT).  If either node is not present, ZERO is used instead
   return (pNode->pLeft ? pNode->pLeft->iHeight : 0) - (pNode->pRight ? pNode->pRight->iHeight : 0);
}


/// Function name  : calculateAVLTreeNodeHeight
// Description     : Calculates the height of a node from the height of it's children
// 
// AVL_TREE_NODE*  pNode : [in/out] Target node
//
// Return Value: 1-based node height
// 
UINT   calculateAVLTreeNodeHeight(AVL_TREE_NODE*  pNode)
{
   AVL_TREE_NODE  *pLeftChild,      // Convenience pointer
                  *pRightChild;     // Convenience pointer
   UINT            iNewHeight;      // Operation result

   // Prepare
   pLeftChild  = pNode->pLeft;
   pRightChild = pNode->pRight;

   // [NO CHILDREN] -- Height is ONE
   if (!pLeftChild AND !pRightChild)
      iNewHeight = 1;

   // [TWO CHILDREN] -- Height is ONE plus the highest child
   else if (pLeftChild AND pRightChild)
      iNewHeight = 1 + max(pLeftChild->iHeight, pRightChild->iHeight);

   // [ONE CHILD] -- Height is ONE plus the child height
   else
      iNewHeight = 1 + (pLeftChild ? pLeftChild->iHeight : pRightChild->iHeight);

   // Return result
   return iNewHeight;
}


/// Function name  : detatchAVLTreeNode
// Description     : Isolates an AVLTree node from the rest of a tree by removing it's parent and child links
// 
// AVL_TREE_NODE*  pNode : [in/out] Node to isolate
// 
VOID  detatchAVLTreeNode(AVL_TREE_NODE*  pNode)
{
   AVL_TREE_NODE*  pParent;      // Parent of the input node

   // Preserve PARENT
   pParent = pNode->pParent;

   /// Break link to CHILDREN
   pNode->pLeft = pNode->pRight = NULL;
   
   // [NO PARENT] Node is the ROOT, and has no parent link to break
   if (!pParent)
      return;

   /// Break the PARENT's link to the node
   if (pNode == pParent->pLeft)
      pParent->pLeft  = NULL;    // Node was left child
   else
      pParent->pRight = NULL;    // Node was right child

   // Break to the NODE's link to the parent
   pNode->pParent = NULL;
}


/// Function name  : findSubTreeMaximum
// Description     : Finds the largest node in the given sub-tree
// 
// CONST AVL_TREE_NODE*  pSubTree  : [in]  Sub-Tree to search
// AVL_TREE_NODE*       &pOutput   : [out] Largest node if found, otherwise NULL
// 
// Return Value   : TRUE if the SubTree exists, otherwise FALSE
// 
BOOL  findSubTreeMaximum(AVL_TREE_NODE*  pSubTree, AVL_TREE_NODE*  &pOutput)
{
   // Prepare
   pOutput = NULL;

   // [CHECK] Does SubTree exist?
   if (!pSubTree)
      return FALSE;

   // [CHECK] Does the sub-tree have a larger node?
   if (pSubTree->pRight)
      // [SUCCESS] Recurse into LEFT sub-tree
      return findSubTreeMaximum(pSubTree->pRight, pOutput);
   
   // [FAILED] This node is the maximum
   pOutput = pSubTree;
   return TRUE;
}


/// Function name  : findSubTreeMinimum
// Description     : Finds the smallest node in the given sub-tree
// 
// CONST AVL_TREE_NODE*  pSubTree  : [in]  Sub-Tree to search
// AVL_TREE_NODE*       &pOutput   : [out] Smallest node if found, otherwise NULL
// 
// Return Value   : TRUE if the SubTree exists, otherwise FALSE
// 
BOOL  findSubTreeMinimum(AVL_TREE_NODE*  pSubTree, AVL_TREE_NODE*  &pOutput)
{
   // Prepare
   pOutput = NULL;

   // [CHECK] Does SubTree exist?
   if (!pSubTree)
      return FALSE;

   // [CHECK] Does the sub-tree have a smaller node?
   if (pSubTree->pLeft)
      // [SUCCESS] Recurse into LEFT sub-tree
      return findSubTreeMinimum(pSubTree->pLeft, pOutput);
   
   // [FAILED] This node is the minimum
   pOutput = pSubTree;
   return TRUE;
}


/// Function name  : getTreeNodeCount
// Description     : Return the number of items in an AVLTree
// 
// CONST AVL_TREE*  pTree : [in] Tree to query
// 
// Return Value   : Number of items within the tree
// 
BearScriptAPI
UINT  getTreeNodeCount(CONST AVL_TREE*  pTree)
{
   return (pTree ? pTree->iCount : 0);
}


/// Function name  : identifyAVLTreeNodeLinkage
// Description     : Determines whether a node is the LEFT/RIGHT CHILD or the TREE ROOT
// 
// CONST AVL_TREE_NODE*  pNode : [in] Node to query
// 
// Return Value   : LEFT CHILD, RIGHT CHILD or TREE ROOT
// 
AVL_TREE_LINKAGE  identifyAVLTreeNodeLinkage(CONST AVL_TREE_NODE*  pNode)
{
   // [CHECK] Does parent exist?
   if (pNode->pParent)
      // [SUCCESS] Determine whether node is the LEFT or RIGHT child
      return (pNode == pNode->pParent->pLeft ? ATL_LEFT : ATL_RIGHT);
   else
      // [FAILED] This node is the ROOT
      return ATL_ROOT;
}


/// Function name  : identifyAVLTreePropertyType
// Description     : Identifies whether a property should be compared a string or integer
// 
// CONST AVL_TREE_SORT_KEY  eProperty   : [in] Property to classify
// 
// Return Value   : Property type
// 
AVL_TREE_PROPERTY_TYPE   identifyAVLTreePropertyType(CONST AVL_TREE_SORT_KEY  eProperty)
{
   switch (eProperty)
   {
   // [INTEGER PROPERTIES]
   case AK_ID:          
   case AK_COUNT:       
   case AK_GROUP:  
   case AK_VALUE:
   case AK_MAINTYPE:
   case AK_PAGE_ID:     
   case AK_VERSION:
      return AP_INTEGER;

   // [STRING PROPERTIES]
   case AK_NAME: 
   case AK_PATH:        
   case AK_TEXT:
   case AK_TYPE:
      return AP_STRING;
   
   // [UNRECOGNISED] Error!
   default:
      ASSERT(FALSE);
      return AP_INTEGER;
   }
}


/// Function name  : swapAVLTreeNode
// Description     : Swaps the data within two nodes
///                         This does not affect either node's position within the tree
// 
// AVL_TREE_NODE*  pFirstNode  : [in] AVLTree node
// AVL_TREE_NODE*  pSecondNode : [in] Another AVLTree node
// 
VOID  swapAVLTreeNode(AVL_TREE_NODE*  pFirstNode, AVL_TREE_NODE*  pSecondNode)
{
   LPARAM  oTemp;

   /// Swap the data via a proxy
   oTemp              = pFirstNode->pData;
   pFirstNode->pData  = pSecondNode->pData;
   pSecondNode->pData = oTemp;
}


/// Function name  : transferAVLTree
// Description     : Helper function for severing trees from one location and moving them to another
// 
// AVL_TREE*  &pSource      : [in] Tree to move, this will be severed
// AVL_TREE*  &pDestination : [in] Destination
// 
BearScriptAPI 
VOID  transferAVLTree(AVL_TREE*  &pSource, AVL_TREE*  &pDestination)
{
   // Copy tree to destination
   pDestination = pSource;
   // Sever original
   pSource = NULL;
}


/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                        FUNCTIONS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : compareAVLTreeNodeWithValues
// Description     : Compares a node in an AVLTree against a specified set of values
///                           The number of values must match the number of tree sort keys
// 
// CONST AVL_TREE*  pTree     : [in] AVLTree containing the nodes
// CONST LPARAM     pNodeData : [in] Data of the node to compare
// ...              ...       : [in] Value to compare node against
// 
// Return Value   : CR_LESSER  : The value is less than the node
//                  CR_EQUAL   : The value is equal to the node
//                  CR_GREATER : The value is more than the node
// 
COMPARISON_RESULT  compareAVLTreeNodeWithValues(CONST AVL_TREE*  pTree, CONST LPARAM  pNodeData, LPARAM  xValue1, LPARAM  xValue2, LPARAM  xValue3)
{
   COMPARISON_RESULT    eResult;         // Comparison result
   CONST AVL_TREE_KEY*  pCurrentKey;     // Convenience pointer
   LPARAM               xNodeProperty,   // Extracted property of the input node
                        xSearchValues[3] = {xValue1, xValue2, xValue3};    // Input values
   // Prepare
   eResult = CR_EQUAL;

   /// Iterate through sort keys
   for (UINT  iKey = 0; (eResult == CR_EQUAL) AND (iKey < pTree->iKeyCount); iKey++)
   {
      // Prepare
      pCurrentKey = pTree->pSortKeys[iKey];

      // Extract appropriate property value from node
      xNodeProperty = extractObjectProperty(pTree, pNodeData, pCurrentKey->eSorting);

      /// [COMPARISON] Compare property against current search value
      switch (pCurrentKey->eType)
      {
      case AP_STRING_CASE: eResult = (COMPARISON_RESULT)StrCmp((TCHAR*)xNodeProperty, (TCHAR*)xSearchValues[iKey]);        break;
      case AP_STRING:      eResult = (COMPARISON_RESULT)StrCmpI((TCHAR*)xNodeProperty, (TCHAR*)xSearchValues[iKey]);        break;
      case AP_INTEGER:     eResult = (COMPARISON_RESULT)utilCompareIntegers((INT)xSearchValues[iKey], (INT)xNodeProperty);  break;
      }

      /// [DIRECTION] Flip the result for descending ordering
      if (pCurrentKey->eDirection == AO_DESCENDING)
         eResult = (COMPARISON_RESULT)(eResult * -1);
   }

   // Return result
   return eResult;
}


/// Function name  : destroyObjectInAVLTreeByIndex
// Description     : Removes and destroys an object in an AVL-Tree by index
// 
// AVL_TREE*   pTree   : [in] Tree containing the object
// CONST UINT  iIndex  : [in] Zero-based index of the object to destroy
// 
// Return Value   : TRUE if object was removed, otherwise FALSE
// 
BearScriptAPI
BOOL   destroyObjectInAVLTreeByIndex(AVL_TREE*  pTree, CONST UINT  iIndex)
{
   LPARAM  pObject;     // Object being destroyed
   BOOL    bResult;     // Operation Result

   // [CHECK] Ensure tree is not a copy tree
   ASSERT(pTree->pfnDeleteNode);

   /// Attempt to remove object from tree
   if (bResult = removeObjectFromAVLTreeByIndex(pTree, iIndex, pObject))
      // [FOUND] Destroy object
      (*pTree->pfnDeleteNode)(pObject);

   // Return result
   return bResult;
}


/// Function name  : destroyObjectFromAVLTreeByValue
// Description     : Removes and destroys an object in an AVL-Tree by Value
// 
// CONST AVL_TREE*  pTree           : [in]            Tree containing the object
// LPARAM           pPrimaryValue   : [in]            Value to match against the primary sort key
// LPARAM           pSecondaryValue : [in] [optional] Value to match against the secondary sort key, if the tree has one.  If not, this value is ignored
// 
// Return Value   : TRUE if object was removed, otherwise FALSE
// 
BearScriptAPI
BOOL   destroyObjectInAVLTreeByValue(AVL_TREE*  pTree, LPARAM  pPrimaryValue, LPARAM  pSecondaryValue)
{
   LPARAM  pObject;     // Object being destroyed

   // [CHECK] Ensure tree is not a copy tree
   ASSERT(pTree->pfnDeleteNode);

   /// Attempt to remove object from tree
   if (!removeObjectFromAVLTreeByValue(pTree, pPrimaryValue, pSecondaryValue, pObject))
      return FALSE;

   // [FOUND] Destroy object
   (*pTree->pfnDeleteNode)(pObject);
   return TRUE;
}


/// Function name  : ensureSubTreeIsBalanced
// Description     : Balances the specified sub-tree and re-calculates the node heights
// 
// AVL_TREE*       pTree     : [in] Tree containing the sub-tree
// AVL_TREE_NODE*  pSubTree  : [in] Sub-tree to balance
// 
VOID  ensureSubTreeIsBalanced(AVL_TREE*  pTree, AVL_TREE_NODE*  pSubTree, CONST AVL_TREE_CHANGE  eCause)
{
   // Examine current balance
   switch (calculateAVLTreeNodeBalance(pSubTree))
   {
   /// [ZERO] -- Do nothing
   case 0:

   /// [ONE] -- Do nothing / Stop searching
   case -1:
   case 1:
      break;

   /// [MINUS 2] -- Too many nodes on the right
   case -2:
      // Examine balance of RIGHT child
      switch (calculateAVLTreeNodeBalance(pSubTree->pRight))
      {
      // [LEFT GRAND-CHILD] : Rotate CHILD right + Rotate ROOT left
      case 1:     performAVLTreeRightRotation(pTree, pSubTree->pRight); 

      // [RIGHT GRAND-CHILD] : Rotate ROOT left
      case -1:    performAVLTreeLeftRotation(pTree, pSubTree);           break;

      // [BALANCED] [REMOVAL] Three nodes on the right and zero on the left, spin to the left to form 2 on the right and 1 on the left
      case 0:
         if (eCause == AC_REMOVAL)
         {
            performAVLTreeLeftRotation(pTree, pSubTree);
            break;
         }
         // Fall through...

      // [ERROR] Balances are corrupt
      default:
         ASSERT(FALSE);
      }
      break;

   /// [PLUS 2] -- Too many nodes on the left
   case 2:
      // Examine balance of LEFT child
      switch (calculateAVLTreeNodeBalance(pSubTree->pLeft))
      {
      // [RIGHT GRAND-CHILD] : Rotate CHILD left + Rotate ROOT right
      case -1:    performAVLTreeLeftRotation(pTree, pSubTree->pLeft);

      // [LEFT GRAND-CHILD] : Rotate ROOT right
      case 1:     performAVLTreeRightRotation(pTree, pSubTree);     break;

      // [BALANCED] [REMOVAL] Three nodes on the left and zero on the right, spin to the right to create 2 on the left and 1 on the right
      case 0:
         if (eCause == AC_REMOVAL)
         {
            performAVLTreeRightRotation(pTree, pSubTree);
            break;
         }
         // Fall through...

      // [ERROR] Balances are corrupt
      default:
         ASSERT(FALSE);
      }
      break;

   // [ERROR] Balances are corrupt
   default:
      ASSERT(FALSE);
      break;
   }
}


/// Function name  : findObjectInAVLTreeByValue
// Description     : Find an object in an AVL Tree, starting at a specified node, by searching for an object with a specific value
// 
// CONST AVL_TREE*  pTree           : [in]            AVL tree to search
// LPARAM           pPrimaryValue   : [in]            Value to match against the primary sort key
// LPARAM           pSecondaryValue : [in] [optional] Value to match against the secondary sort key, if the tree has one.  If not, this value is ignored
// LPARAM          &pOutput         : [out]           Desired object if found, otherwise NULL
// AVL_TREE_NODE*   pCurrentNode    : [in] [optional] Node currently being examined
///                                                        Must be NULL on initial call
// 
// Return Value   : TRUE if found, FALSE otherwise
// 
BearScriptAPI
BOOL   findObjectInAVLTreeByValue(CONST AVL_TREE*  pTree, LPARAM  pPrimaryValue, LPARAM  pSecondaryValue, LPARAM&  pOutput, AVL_TREE_NODE*  pCurrentNode)
{
   BOOL   bResult;        // Operation result

   // Prepare
   bResult = FALSE;

   // [CHECK] Is this the initial call?
   if (pCurrentNode == NULL)
   {
      // Start search from the root
      pCurrentNode = pTree->pRoot;
      pOutput      = NULL;

      // [CHECK] Return FALSE if the tree is empty
      if (pTree->pRoot == NULL)
         return FALSE;
   }

   /// [COMPARE] Compare current node with values
   switch (compareAVLTreeNodeWithValues(pTree, pCurrentNode->pData, pPrimaryValue, pSecondaryValue, NULL))
   {
   /// [LESSER] Search left sub-tree
   case CR_LESSER:
      // [CHECK] Is there a left sub-tree to search?
      if (pCurrentNode->pLeft)
         // [SUCCESS] Search left sub-tree
         bResult = findObjectInAVLTreeByValue(pTree, pPrimaryValue, pSecondaryValue, pOutput, pCurrentNode->pLeft);
      break;

   /// [EQUAL] Set result and return TRUE
   case CR_EQUAL:
      pOutput = pCurrentNode->pData;
      bResult = TRUE;
      break;

   /// [GREATER] Search right sub-tree
   case CR_GREATER:
      // [CHECK] Is there a larger node available?
      if (pCurrentNode->pRight)
         // [SUCCESS] Search right sub-tree
         bResult = findObjectInAVLTreeByValue(pTree, pPrimaryValue, pSecondaryValue, pOutput, pCurrentNode->pRight);
      break;
   }
  
   // Return result
   return bResult;
}


/// Function name  : findObjectInAVLTreeByIndex
// Description     : Search an AVL tree for the object at the specified index
///                                             Requires the tree to have been previously indexed
// 
// CONST AVL_TREE*   pTree        : [in]            AVL Tree to search
// CONST UINT        iIndex       : [in]            Desired index
// LPARAM&           pOutput      : [out]           Object if found, otherwise NULL
// AVL_TREE_NODE*    pCurrentNode : [in] [optional] The node currently being examined
///                                                        Must be NULL on initial call
// 
// Return type : TRUE if object was found, otherwise FALSE
//
BearScriptAPI
BOOL   findObjectInAVLTreeByIndex(CONST AVL_TREE*  pTree, CONST UINT  iIndex, LPARAM &pOutput, AVL_TREE_NODE*  pCurrentNode)
{
   BOOL   bResult;      // Operation result

   // Prepare
   bResult = FALSE;
   
   // [CHECK] Is this the initial call?
   if (pCurrentNode == NULL)
   {
      // Start search from the root
      pCurrentNode = pTree->pRoot;
      pOutput      = NULL;

      // [CHECK] Return FALSE if the tree is empty
      if (pTree->pRoot == NULL)
         return FALSE;
   }

   // [CHECK] Ensure tree is indexed
   ASSERT(pTree->bIndexed);

   /// [LESSER] Recurse into left sub-tree
   if (iIndex < pCurrentNode->iIndex)
   {
      // [CHECK] Is there a left-subtree?
      if (pCurrentNode->pLeft)
         bResult = findObjectInAVLTreeByIndex(pTree, iIndex, pOutput, pCurrentNode->pLeft);
   }
   /// [GREATER] Recurse into right sub-tree
   else if (iIndex > pCurrentNode->iIndex)
   {
      // [CHECK] Is there a right-subtree?
      if (pCurrentNode->pRight)
         bResult = findObjectInAVLTreeByIndex(pTree, iIndex, pOutput, pCurrentNode->pRight);
   }
   /// [EQUAL] Set result and return TRUE
   else
   {
      pOutput = pCurrentNode->pData;
      bResult = TRUE;
   }

   // Return result
   return bResult;
}


/// Function name  : insertObjectIntoAVLTree
// Description     : Inserts an object into an AVL tree at the appropriate position, given the tree's sort key(s).
///                    -> Rebalances the tree as necessary.
///                    -> Inserting a new node invalidates the indexing.
// 
// AVL_TREE*        pTree        : [in]            Target tree
// LPARAM           pNewObject   : [in]            Object to be to inserted
// AVL_TREE_NODE*   pCurrentNode : [in] [optional] Node currently being processed
///                                                        Must be NULL on initial call
//
// Return Type : TRUE if inserted, FALSE if it was already present
//
BearScriptAPI
BOOL   insertObjectIntoAVLTree(AVL_TREE*  pTree, LPARAM  pNewObject, AVL_TREE_NODE*  pCurrentNode)
{
   BOOL    bResult;            // Operation result, defaults to FALSE
   LPARAM  xSearchValues[3];

   // Prepare
   bResult = FALSE;

   /// [CHECK] Is Tree Empty?
   if (pTree->pRoot == NULL)
   {
      // [SUCCESS] Insert node as new ROOT and return TRUE
      pTree->pRoot = createAVLTreeNode(pTree, NULL, pNewObject);
      return TRUE;
   }
   // [CHECK] Is this the initial call?
   else if (pCurrentNode == NULL)
      // [SUCCESS] Start search at ROOT
      pCurrentNode = pTree->pRoot;

   // Extract search values from input object
   for (UINT  iKey = 0; iKey < pTree->iKeyCount; iKey++)
      xSearchValues[iKey] = extractObjectProperty(pTree, pNewObject, pTree->pSortKeys[iKey]->eSorting);

   /// [COMPARE] Compare current node with values
   switch (compareAVLTreeNodeWithValues(pTree, pCurrentNode->pData, xSearchValues[0], xSearchValues[1], xSearchValues[2]))
   {
   /// [LESS THAN] - Insert/Recurse into left child
   case CR_LESSER:
      // [CHECK] Does LEFT CHILD already exist?
      if (pCurrentNode->pLeft)
         // [FAILURE] Attempt to insert into left child
         bResult = insertObjectIntoAVLTree(pTree, pNewObject, pCurrentNode->pLeft);
      else
      {
         // [SUCCESS] Insert object in a new tree node here
         pCurrentNode->pLeft = createAVLTreeNode(pTree, pCurrentNode, pNewObject);

         // Return TRUE
         bResult = TRUE;
      }
      break;

   /// [GREATER THAN] - Insert/Recurse into right child
   case CR_GREATER:
      // Examine the right child
      if (pCurrentNode->pRight)
         // [EXISTS] Pass to right child
         bResult = insertObjectIntoAVLTree(pTree, pNewObject, pCurrentNode->pRight);
      else
      {
         // [EMPTY] Insert object into a new tree node here
         pCurrentNode->pRight = createAVLTreeNode(pTree, pCurrentNode, pNewObject);

         // Return TRUE
         bResult = TRUE;
      }
      break;
   }

   // [CHECK] Has tree been changed?
   if (bResult)
   {
      // Remove the indexing flag
      pTree->bIndexed = FALSE;

      // Recalculate node height
      pCurrentNode->iHeight = calculateAVLTreeNodeHeight(pCurrentNode);

      // Ensure subtree is balanced
      ensureSubTreeIsBalanced(pTree, pCurrentNode, AC_INSERTION);
   }

   // Return TRUE if object was inserted, FALSE otherwise
   return bResult;
}


/// Function name  : performAVLTreeLeftRotation
// Description     : Perform a 'left' rotation on a node
//
//                      P                   Q
//                     / \                 / \
//                    a   Q     ---->     P   c
//                       / \             / \   
//                      b   c           a   b 
// 
// AVL_TREE_NODE*  pSubTree : [in] SubTree to perform a LEFT rotation upon 
//
VOID  performAVLTreeLeftRotation(AVL_TREE*  pTree, AVL_TREE_NODE*  pSubTree)
{
   AVL_TREE_LINKAGE   eSubTreeLinkage;      // Whether 'P' is a left or right child
   AVL_TREE_NODE     *pSubTreeParent,       // Parent of 'P'
                     *pNodeP,               // Node 'P'
                     *pNodeQ;               // Node 'Q'
   // Prepare
   pNodeP = pSubTree;
   pNodeQ = pSubTree->pRight;

   // Preserve Node's parent and linkage
   pSubTreeParent  = pSubTree->pParent;
   eSubTreeLinkage = identifyAVLTreeNodeLinkage(pSubTree);

   // [CHECK] Does 'b' exist?
   if (pNodeQ->pLeft)
      // [SUCCESS] Change 'b' from left(Q) to right(P)
      attachAVLTreeNodeToParent(pTree, pNodeP, pNodeQ->pLeft, ATL_RIGHT);
   else
      // [FAILURE] Set right(P) to NULL
      pNodeP->pRight = NULL;

   // Change 'P' from linkage(SubTreeParent) to left(Q)
   attachAVLTreeNodeToParent(pTree, pNodeQ, pNodeP, ATL_LEFT);

   // Change 'Q' from right(P) to linkage(SubTreeParent)
   attachAVLTreeNodeToParent(pTree, pSubTreeParent, pNodeQ, eSubTreeLinkage);

   /// Recalculate height of 'P' and 'Q'
   pNodeP->iHeight = calculateAVLTreeNodeHeight(pNodeP);
   pNodeQ->iHeight = calculateAVLTreeNodeHeight(pNodeQ);
}


/// Function name  : performAVLTreeRightRotation
// Description     : Perform a 'right' rotation on a node
// 
//                      Q               P
//                     / \             / \
//                    P   c    -->    a   Q
//                   / \                 / \
//                  a   b               b   c
//
// AVL_TREE_NODE*  pSubTree : [in] SubTree to perform a RIGHT rotation upon
// 
VOID  performAVLTreeRightRotation(AVL_TREE*  pTree, AVL_TREE_NODE*  pSubTree)
{
   AVL_TREE_LINKAGE   eSubTreeLinkage;      // Whether 'Q' is a left or right child
   AVL_TREE_NODE     *pSubTreeParent,       // Parent of 'Q'
                     *pNodeP,               // Node 'P'
                     *pNodeQ;               // Node 'Q'
   // Prepare
   pNodeQ = pSubTree;
   pNodeP = pSubTree->pLeft;

   // Preserve Node's parent and linkage
   pSubTreeParent  = pSubTree->pParent;
   eSubTreeLinkage = identifyAVLTreeNodeLinkage(pSubTree);

   // [CHECK] Does 'b' exist?
   if (pNodeP->pRight)
      // [SUCCESS] Change 'b' from right(P) to left(Q)
      attachAVLTreeNodeToParent(pTree, pNodeQ, pNodeP->pRight, ATL_LEFT);
   else
      // [FAILURE] Set left(Q) to NULL
      pNodeQ->pLeft = NULL;

   // Change 'Q' from linkage(SubTreeParent) to right(P)
   attachAVLTreeNodeToParent(pTree, pNodeP, pNodeQ, ATL_RIGHT);

   // Change 'P' from left(Q) to linkage(SubTreeParent)
   attachAVLTreeNodeToParent(pTree, pSubTreeParent, pNodeP, eSubTreeLinkage);

   /// Recalculate height of 'Q' and 'P'
   pNodeQ->iHeight = calculateAVLTreeNodeHeight(pNodeQ);
   pNodeP->iHeight = calculateAVLTreeNodeHeight(pNodeP);
}


/// Function name  : removeAVLTreePredecessorNode
// Description     : Finds the in-order predecessor of a given node, swaps contents with it, then destroys it.
///                        Rebalancing is performed as required up to, but not including, the input node
// 
// AVL_TREE*       pTree        : [in] Tree containing the node
// AVL_TREE_NODE*  pSubTree     : [in] Input node
// AVL_TREE_NODE*  pCurrentNode : [in] Node currently being examined, used in recursion.
///                                       Must be NULL on first call
// 
VOID  removeAVLTreePredecessorNode(AVL_TREE*  pTree, AVL_TREE_NODE*  pSubTree, AVL_TREE_NODE*  pCurrentNode /*= NULL*/)
{
   AVL_TREE_NODE*   pDestructionNode;     // Actual node to destroy after data has been swapped

   // Prepare
   pDestructionNode = NULL;

   // [CHECK] Assure input SubTree has a LEFT CHILD
   ASSERT(pSubTree->pLeft);

   // [INITIAL CALL] Start searching from the left sub-tree?
   if (pCurrentNode == NULL)
      pCurrentNode = pSubTree->pLeft;

   // [CHECK] Is this the in-order predecessor?  (ie. largest value)
   if (pCurrentNode->pRight)
      // [FAILED] Recurse into RIGHT sub-tree
      removeAVLTreePredecessorNode(pTree, pSubTree, pCurrentNode->pRight);
   else
   {
      /// [SUCCESS] Swap content of CURRENT NODE with INPUT NODE
      swapAVLTreeNode(pCurrentNode, pSubTree);
   
      // [CHECK] Does CURRENT NODE have ZERO CHILDREN?
      if (pCurrentNode->pLeft == NULL)
      {
         /// [NODE IS LEAF] Destroy the CURRENT NODE and perform NO balancing
         pDestructionNode = pCurrentNode;
         pCurrentNode = NULL;
      }
      else 
      {
         /// [NODE HAS LEFT-CHILD] Swap content of CURRENT NODE with LEFT-CHILD 
         swapAVLTreeNode(pCurrentNode, pCurrentNode->pLeft);
         // Destroy LEFT-CHILD
         pDestructionNode = pCurrentNode->pLeft;
      }

      // [CHECK] Sever/Destroy the node marked for destruction, if any
      if (pDestructionNode)
      {
         detatchAVLTreeNode(pDestructionNode);
         deleteAVLTreeNode(pTree, pDestructionNode, FALSE);
      }
   }

   // [CHECK] Don't attempt to rebalance the node if we just destroyed it
   if (pCurrentNode)
   {
      // [SUCCESS] Recalculate height and re-balance appropriately
      pCurrentNode->iHeight = calculateAVLTreeNodeHeight(pCurrentNode);
      ensureSubTreeIsBalanced(pTree, pCurrentNode, AC_REMOVAL);
   }
}


/// Function name  : removeObjectFromAVLTreeByIndex
// Description     : Removes without destroying an object in an AVLTree by index
// 
// CONST AVL_TREE*  pTree        : [in]            AVL tree to search
// CONST UINT       iIndex       : [in]            Zero-based index
// LPARAM          &pOutput      : [out]           Desired object if found, otherwise NULL
// AVL_TREE_NODE*   pCurrentNode : [in] [optional] Node currently being examined.
///                                                        Must be NULL on initial call
// 
// Return Value   : TRUE if found, FALSE otherwise
// 
BearScriptAPI
BOOL   removeObjectFromAVLTreeByIndex(AVL_TREE*  pTree, CONST UINT  iIndex, LPARAM&  pOutput, AVL_TREE_NODE*  pCurrentNode)
{
   AVL_TREE_NODE*   pDestructionNode;   // The node that is finally destroyed after the target content is switched between (up to three) nodes
   BOOL             bResult;            // Operation result

   // Prepare
   bResult = FALSE;

   // [CHECK] Is this the initial call?
   if (pCurrentNode == NULL)
   {
      // Start search from the root
      pCurrentNode = pTree->pRoot;
      pOutput      = NULL;

      // [CHECK] Return FALSE if the tree is empty
      if (pTree->pRoot == NULL)
         return FALSE;

      // [CHECK] Ensure tree is indexed
      ASSERT(pTree->bIndexed);
   }

   /// [LESSER] Search left sub-tree
   if (iIndex < pCurrentNode->iIndex)
   {
      // [CHECK] Is there a left sub-tree to search?
      if (pCurrentNode->pLeft)
         // [SUCCESS] Search left sub-tree
         bResult = removeObjectFromAVLTreeByIndex(pTree, iIndex, pOutput, pCurrentNode->pLeft);
   }
   /// [GREATER] Search right sub-tree
   else if (iIndex > pCurrentNode->iIndex)
   {
      // [CHECK] Is there a larger node available?
      if (pCurrentNode->pRight)
         // [SUCCESS] Search right sub-tree
         bResult = removeObjectFromAVLTreeByIndex(pTree, iIndex, pOutput, pCurrentNode->pRight);
   }
   // [EQUAL] Extract object and delete container node
   else
   {
      // [FOUND] Return object and set result
      pOutput = pCurrentNode->pData;
      bResult = TRUE;

      /// [NODE IS LEAF] Destroy the CURRENT NODE and return TRUE
      if (!pCurrentNode->pLeft AND !pCurrentNode->pRight)
      {
         // Destroy current node.  Zero 'CurrentNode' so we don't attempt to rebalance it!
         pDestructionNode = pCurrentNode;
         pCurrentNode = NULL;

         // [CHECK] Ensure ROOT is zero'd if this is the last node in the tree
         if (pTree->pRoot == pDestructionNode)
            // [FIX] BUG:1024 "An access violation occurs when loading Jack08's supplementary language file '7212-L044.xml'"
            pTree->pRoot = NULL;
      }
      /// [NODE HAS ONE CHILD] Swap content with and destroy CHILD.
      else if (!pCurrentNode->pLeft OR !pCurrentNode->pRight)
      {   
         // Swap CURRENT NODE with CHILD
         swapAVLTreeNode(pCurrentNode, findSingleChildNode(pCurrentNode));
         // Destroy CHILD. Start rebalancing at CURRENT NODE.
         pDestructionNode = findSingleChildNode(pCurrentNode);
      }
      else
      {
         /// [NODE HAS TWO CHILDREN] Swap CURRENT NODE with IN-ORDER PREDECESSOR, then delete that.
         removeAVLTreePredecessorNode(pTree, pCurrentNode); 
         pDestructionNode = NULL;
      }
      
      // [CHECK] Does a node need destroying?
      if (pDestructionNode)
      {
         /// Sever/Destroy the node marked for destruction WITHOUT destroying the content
         detatchAVLTreeNode(pDestructionNode);
         deleteAVLTreeNode(pTree, pDestructionNode, FALSE);
      }

      // Fall through to recalculate height and check balances
   }

   // [CHECK] Has a non-leaf been removed?
   if (bResult AND pCurrentNode)  
   {
      /// [SUCCESS] Recalculate node height then ensure balancing is maintained
      pCurrentNode->iHeight = calculateAVLTreeNodeHeight(pCurrentNode);
      ensureSubTreeIsBalanced(pTree, pCurrentNode, AC_REMOVAL);

      // Remove the indexing flag
      pTree->bIndexed = FALSE;
   }

   // Return result
   return bResult;
}


/// Function name  : removeObjectFromAVLTreeByValue
// Description     : Removes without destroying an object in an AVLTree by VALUE
// 
// CONST AVL_TREE*  pTree           : [in]            AVL tree to search
// LPARAM           pPrimaryValue   : [in]            Value to match against the primary sort key
// LPARAM           pSecondaryValue : [in] [optional] Value to match against the secondary sort key, if the tree has one.  If not, this value is ignored
// LPARAM          &pOutput         : [out]           Desired object if found, otherwise NULL
// AVL_TREE_NODE*   pCurrentNode    : [in] [optional] Node currently being examined.
///                                                        Must be NULL on initial call
// 
// Return Value   : TRUE if found, FALSE otherwise
// 
BearScriptAPI
BOOL   removeObjectFromAVLTreeByValue(AVL_TREE*  pTree, LPARAM  pPrimaryValue, LPARAM  pSecondaryValue, LPARAM&  pOutput, AVL_TREE_NODE*  pCurrentNode)
{
   AVL_TREE_NODE*     pDestructionNode;   // The node that is finally destroyed after the target content is switched between (up to three) nodes
   BOOL               bResult;            // Operation result

   // Prepare
   bResult = FALSE;

   // [CHECK] Is this the initial call?
   if (pCurrentNode == NULL)
   {
      // Start search from the root
      pCurrentNode = pTree->pRoot;
      pOutput      = NULL;

      // [CHECK] Return FALSE if the tree is empty
      if (pTree->pRoot == NULL)
         return FALSE;
   }

   /// [COMPARE] Compare current node with values
   switch (compareAVLTreeNodeWithValues(pTree, pCurrentNode->pData, pPrimaryValue, pSecondaryValue, NULL))
   {
   /// [LESSER] Search left sub-tree
   case CR_LESSER:
      // [CHECK] Is there a left sub-tree to search?
      if (pCurrentNode->pLeft)
         // [SUCCESS] Search left sub-tree
         bResult = removeObjectFromAVLTreeByValue(pTree, pPrimaryValue, pSecondaryValue, pOutput, pCurrentNode->pLeft);
      break;

   /// [GREATER] Search right sub-tree
   case CR_GREATER:
      // [CHECK] Is there a larger node available?
      if (pCurrentNode->pRight)
         // [SUCCESS] Search right sub-tree
         bResult = removeObjectFromAVLTreeByValue(pTree, pPrimaryValue, pSecondaryValue, pOutput, pCurrentNode->pRight);
      break;

   // [EQUAL] Extract object and delete container node
   case CR_EQUAL:
      // [FOUND] Return object and set result
      pOutput = pCurrentNode->pData;
      bResult = TRUE;

      /// [NODE IS LEAF] Destroy the CURRENT NODE and return TRUE
      if (!pCurrentNode->pLeft AND !pCurrentNode->pRight)
      {
         // Destroy current node.  Zero 'CurrentNode' so we don't attempt to rebalance it!
         pDestructionNode = pCurrentNode;
         pCurrentNode     = NULL;

         // [CHECK] Ensure ROOT is zero'd if this is the last node in the tree
         if (pTree->pRoot == pDestructionNode)
            // [FIX] BUG:1024 "An access violation occurs when loading Jack08's supplementary language file '7212-L044.xml'"
            pTree->pRoot = NULL;
      }
      /// [NODE HAS ONE CHILD] Swap content with and destroy CHILD.
      else if (!pCurrentNode->pLeft OR !pCurrentNode->pRight)
      {   
         // Swap CURRENT NODE with CHILD
         swapAVLTreeNode(pCurrentNode, findSingleChildNode(pCurrentNode));
         // Destroy CHILD. Start rebalancing at CURRENT NODE.
         pDestructionNode = findSingleChildNode(pCurrentNode);
      }
      else
      {
         /// [NODE HAS TWO CHILDREN] Swap CURRENT NODE with IN-ORDER PREDECESSOR, then delete that.
         removeAVLTreePredecessorNode(pTree, pCurrentNode); 
         pDestructionNode = NULL;
      }
      
      // [CHECK] Does a node need destroying?
      if (pDestructionNode)
      {
         /// Sever/Destroy the node marked for destruction WITHOUT destroying the content
         detatchAVLTreeNode(pDestructionNode);
         deleteAVLTreeNode(pTree, pDestructionNode, FALSE);
      }

      // Fall through to recalculate height and check balances
   }

   // [CHECK] Has a non-leaf been removed?
   if (bResult AND pCurrentNode)  
   {
      /// [SUCCESS] Recalculate node height then ensure balancing is maintained
      pCurrentNode->iHeight = calculateAVLTreeNodeHeight(pCurrentNode);
      ensureSubTreeIsBalanced(pTree, pCurrentNode, AC_REMOVAL);

      // Remove the indexing flag
      pTree->bIndexed = FALSE;
   }

   // Return result
   return bResult;
}

